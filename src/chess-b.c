#import <stdio.h>
#import <stdlib.h>
#import <limits.h>
#import <string.h>
#include <stdint.h>
#include <inttypes.h>

// Fast base 2 log (for converting bitboard->int)
#define LOG2(X) ((unsigned) (8*sizeof (unsigned long long) - __builtin_clzll((X)) - 1))

// Truth values
#define FALSE 0
#define TRUE 	1
//Colours
#define WHITE 0
#define BLACK 1
// Results
#define RES_DRAW 					0
#define RES_WHITE_WIN 		1
#define RES_BLACK_WIN 		2

#define RES_STALEMATE 		3
#define RES_THREEFOLD  		4
#define RES_FIFTY_MOVE 		5
#define RES_UNFINISHED 		6
#define RES_INSUFF_MATERIAL 7

// Ai Modes
#define NORMAL_AI 0
#define DIRTY_AI 1
// Move flags
#define FLAG_QUIET_MOVE					 0
#define FLAG_PAWN_PUSH 					(1<<0)
#define FLAG_DOUBLE_PAWN_PUSH 	(1<<1)
#define FLAG_KING_CASTLE				(1<<2)
#define FLAG_QUEEN_CASTLE				(1<<3)
#define FLAG_CAPTURES						(1<<4)
#define FLAG_EP_CAPTURE					(1<<5)
#define FLAG_PROMO							(1<<6)
#define FLAG_KNIGHT_PROMO				(1<<7)
#define FLAG_BISHOP_PROMO				(1<<8)
#define FLAG_ROOK_PROMO					(1<<9)
#define FLAG_QUEEN_PROMO				(1<<10)
#define FLAG_KNIGHT_PROMO_CAPT	(1<<11)
#define FLAG_BISHOP_PROMO_CAPT	(1<<12)
#define FLAG_ROOK_PROMO_CAPT		(1<<13)
#define FLAG_QUEEN_PROMO_CAPT		(1<<14)
// Board flags
#define W_KSIDE_CASTLE (1<<0)
#define W_QSIDE_CASTLE (1<<1)
#define B_KSIDE_CASTLE (1<<2)
#define B_QSIDE_CASTLE (1<<3)

// Pieces
#define WHITE 		0
#define BLACK			1
#define W_PAWN 		2
#define W_KNIGHT 	3
#define W_BISHOP 	4
#define W_ROOK 		5
#define W_QUEEN 	6
#define W_KING 		7
#define B_PAWN 		8
#define B_KNIGHT 	9
#define B_BISHOP 	10
#define B_ROOK 		11
#define B_QUEEN 	12
#define B_KING 		13

// Ray directions

#define DIR_N 	0
#define DIR_E		1
#define DIR_NW	2
#define DIR_NE	3
#define DIR_S		4
#define DIR_W		5
#define DIR_SE	6
#define DIR_SW	7


// Square indices
#define A1_INT 0
#define B1_INT 1
#define C1_INT 2
#define D1_INT 3
#define E1_INT 4
#define F1_INT 5
#define G1_INT 6
#define H1_INT 7
#define A2_INT 8
#define B2_INT 9
#define C2_INT 10
#define D2_INT 11
#define E2_INT 12
#define F2_INT 13
#define G2_INT 14
#define H2_INT 15
#define A3_INT 16
#define B3_INT 17
#define C3_INT 18
#define D3_INT 19
#define E3_INT 20
#define F3_INT 21
#define G3_INT 22
#define H3_INT 23
#define A4_INT 24
#define B4_INT 25
#define C4_INT 26
#define D4_INT 27
#define E4_INT 28
#define F4_INT 29
#define G4_INT 30
#define H4_INT 31
#define A5_INT 32
#define B5_INT 33
#define C5_INT 34
#define D5_INT 35
#define E5_INT 36
#define F5_INT 37
#define G5_INT 38
#define H5_INT 39
#define A6_INT 40
#define B6_INT 41
#define C6_INT 42
#define D6_INT 43
#define E6_INT 44
#define F6_INT 45
#define G6_INT 46
#define H6_INT 47
#define A7_INT 48
#define B7_INT 49
#define C7_INT 50
#define D7_INT 51
#define E7_INT 52
#define F7_INT 53
#define G7_INT 54
#define H7_INT 55
#define A8_INT 56
#define B8_INT 57
#define C8_INT 58
#define D8_INT 59
#define E8_INT 60
#define F8_INT 61
#define G8_INT 62
#define H8_INT 63

// Bitboard constants. Generated by gen.py
const uint64_t ONE64BIT = 1;
const uint64_t A1 = (ONE64BIT<<A1_INT);
const uint64_t B1 = (ONE64BIT<<B1_INT);
const uint64_t C1 = (ONE64BIT<<C1_INT);
const uint64_t D1 = (ONE64BIT<<D1_INT);
const uint64_t E1 = (ONE64BIT<<E1_INT);
const uint64_t F1 = (ONE64BIT<<F1_INT);
const uint64_t G1 = (ONE64BIT<<G1_INT);
const uint64_t H1 = (ONE64BIT<<H1_INT);
const uint64_t A2 = (ONE64BIT<<A2_INT);
const uint64_t B2 = (ONE64BIT<<B2_INT);
const uint64_t C2 = (ONE64BIT<<C2_INT);
const uint64_t D2 = (ONE64BIT<<D2_INT);
const uint64_t E2 = (ONE64BIT<<E2_INT);
const uint64_t F2 = (ONE64BIT<<F2_INT);
const uint64_t G2 = (ONE64BIT<<G2_INT);
const uint64_t H2 = (ONE64BIT<<H2_INT);
const uint64_t A3 = (ONE64BIT<<A3_INT);
const uint64_t B3 = (ONE64BIT<<B3_INT);
const uint64_t C3 = (ONE64BIT<<C3_INT);
const uint64_t D3 = (ONE64BIT<<D3_INT);
const uint64_t E3 = (ONE64BIT<<E3_INT);
const uint64_t F3 = (ONE64BIT<<F3_INT);
const uint64_t G3 = (ONE64BIT<<G3_INT);
const uint64_t H3 = (ONE64BIT<<H3_INT);
const uint64_t A4 = (ONE64BIT<<A4_INT);
const uint64_t B4 = (ONE64BIT<<B4_INT);
const uint64_t C4 = (ONE64BIT<<C4_INT);
const uint64_t D4 = (ONE64BIT<<D4_INT);
const uint64_t E4 = (ONE64BIT<<E4_INT);
const uint64_t F4 = (ONE64BIT<<F4_INT);
const uint64_t G4 = (ONE64BIT<<G4_INT);
const uint64_t H4 = (ONE64BIT<<H4_INT);
const uint64_t A5 = (ONE64BIT<<A5_INT);
const uint64_t B5 = (ONE64BIT<<B5_INT);
const uint64_t C5 = (ONE64BIT<<C5_INT);
const uint64_t D5 = (ONE64BIT<<D5_INT);
const uint64_t E5 = (ONE64BIT<<E5_INT);
const uint64_t F5 = (ONE64BIT<<F5_INT);
const uint64_t G5 = (ONE64BIT<<G5_INT);
const uint64_t H5 = (ONE64BIT<<H5_INT);
const uint64_t A6 = (ONE64BIT<<A6_INT);
const uint64_t B6 = (ONE64BIT<<B6_INT);
const uint64_t C6 = (ONE64BIT<<C6_INT);
const uint64_t D6 = (ONE64BIT<<D6_INT);
const uint64_t E6 = (ONE64BIT<<E6_INT);
const uint64_t F6 = (ONE64BIT<<F6_INT);
const uint64_t G6 = (ONE64BIT<<G6_INT);
const uint64_t H6 = (ONE64BIT<<H6_INT);
const uint64_t A7 = (ONE64BIT<<A7_INT);
const uint64_t B7 = (ONE64BIT<<B7_INT);
const uint64_t C7 = (ONE64BIT<<C7_INT);
const uint64_t D7 = (ONE64BIT<<D7_INT);
const uint64_t E7 = (ONE64BIT<<E7_INT);
const uint64_t F7 = (ONE64BIT<<F7_INT);
const uint64_t G7 = (ONE64BIT<<G7_INT);
const uint64_t H7 = (ONE64BIT<<H7_INT);
const uint64_t A8 = (ONE64BIT<<A8_INT);
const uint64_t B8 = (ONE64BIT<<B8_INT);
const uint64_t C8 = (ONE64BIT<<C8_INT);
const uint64_t D8 = (ONE64BIT<<D8_INT);
const uint64_t E8 = (ONE64BIT<<E8_INT);
const uint64_t F8 = (ONE64BIT<<F8_INT);
const uint64_t G8 = (ONE64BIT<<G8_INT);
const uint64_t H8 = (ONE64BIT<<H8_INT);

const uint64_t A_FILE = (A1|A2|A3|A4|A5|A6|A7|A8);
const uint64_t B_FILE = (B1|B2|B3|B4|B5|B6|B7|B8);
const uint64_t C_FILE = (C1|C2|C3|C4|C5|C6|C7|C8);
const uint64_t D_FILE = (D1|D2|D3|D4|D5|D6|D7|D8);
const uint64_t E_FILE = (E1|E2|E3|E4|E5|E6|E7|E8);
const uint64_t F_FILE = (F1|F2|F3|F4|F5|F6|F7|F8);
const uint64_t G_FILE = (G1|G2|G3|G4|G5|G6|G7|G8);
const uint64_t H_FILE = (H1|H2|H3|H4|H5|H6|H7|H8);

const uint64_t RANK_1 = (A1|B1|C1|D1|E1|F1|G1|H1);
const uint64_t RANK_2 = (A2|B2|C2|D2|E2|F2|G2|H2);
const uint64_t RANK_3 = (A3|B3|C3|D3|E3|F3|G3|H3);
const uint64_t RANK_4 = (A4|B4|C4|D4|E4|F4|G4|H4);
const uint64_t RANK_5 = (A5|B5|C5|D5|E5|F5|G5|H5);
const uint64_t RANK_6 = (A6|B6|C6|D6|E6|F6|G6|H6);
const uint64_t RANK_7 = (A7|B7|C7|D7|E7|F7|G7|H7);
const uint64_t RANK_8 = (A8|B8|C8|D8|E8|F8|G8|H8);

const uint64_t CENTRE_SQUARES = (D4|E4|D5|E5);
const uint64_t BIG_CENTRE_SQUARES = (RANK_3|RANK_4|RANK_5|RANK_6) & (C_FILE|D_FILE|E_FILE|F_FILE);
const uint64_t EDGE_SQUARES = (A_FILE | H_FILE | RANK_1 | RANK_8);

const uint64_t LIGHT_SQUARES = (B1|D1|F1|H1|A2|C2|E2|G2|B3|D3|F3|H3|A4|C4|E4|G4|B5|D5|F5|H5|A6|C6|E6|G6|B7|D7|F7|H7|A8|C8|E8|G8);
const uint64_t DARK_SQUARES = (A1|C1|E1|G1|B2|D2|F2|H2|A3|C3|E3|G3|B4|D4|F4|H4|A5|C5|E5|G5|B6|D6|F6|H6|A7|C7|E7|G7|B8|D8|F8|H8);

const uint64_t W_KSIDE_CASTLE_SQUARES = (E1|H1);
const uint64_t W_QSIDE_CASTLE_SQUARES = (E1|A1);
const uint64_t B_KSIDE_CASTLE_SQUARES = (E8|H8);
const uint64_t B_QSIDE_CASTLE_SQUARES = (E8|A8);
const uint64_t CASTLE_SQUARES = (A1|E1|H1|A8|E8|H8);

const int MAILBOX120[120] = {
     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
     -1,  0,  1,  2,  3,  4,  5,  6,  7, -1,
     -1,  8,  9, 10, 11, 12, 13, 14, 15, -1,
     -1, 16, 17, 18, 19, 20, 21, 22, 23, -1,
     -1, 24, 25, 26, 27, 28, 29, 30, 31, -1,
     -1, 32, 33, 34, 35, 36, 37, 38, 39, -1,
     -1, 40, 41, 42, 43, 44, 45, 46, 47, -1,
     -1, 48, 49, 50, 51, 52, 53, 54, 55, -1,
     -1, 56, 57, 58, 59, 60, 61, 62, 63, -1,
     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
     -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};

const int MAILBOX64[64] = {
    21, 22, 23, 24, 25, 26, 27, 28,
    31, 32, 33, 34, 35, 36, 37, 38,
    41, 42, 43, 44, 45, 46, 47, 48,
    51, 52, 53, 54, 55, 56, 57, 58,
    61, 62, 63, 64, 65, 66, 67, 68,
    71, 72, 73, 74, 75, 76, 77, 78,
    81, 82, 83, 84, 85, 86, 87, 88,
    91, 92, 93, 94, 95, 96, 97, 98
};

// MAGIC BIT CONSTANTS
// DEBRUIJN TABLES, FOR FAST BitScan()
const int DEBRUIJN_TABLE[64] = {
    0,  1, 48,  2, 57, 49, 28,  3,
   61, 58, 50, 42, 38, 29, 17,  4,
   62, 55, 59, 36, 53, 51, 43, 22,
   45, 39, 33, 30, 24, 18, 12,  5,
   63, 47, 56, 27, 60, 41, 37, 16,
   54, 35, 52, 21, 44, 32, 23, 11,
   46, 26, 40, 15, 34, 20, 31, 10,
   25, 14, 19,  9, 13,  8,  7,  6
};

const int REVERSE_DEBRUIJN_TABLE[64] = {
    0, 47,  1, 56, 48, 27,  2, 60,
   57, 49, 41, 37, 28, 16,  3, 61,
   54, 58, 35, 52, 50, 42, 21, 44,
   38, 32, 29, 23, 17, 11,  4, 62,
   46, 55, 26, 59, 40, 36, 15, 53,
   34, 51, 20, 43, 31, 22, 10, 45,
   25, 39, 14, 33, 19, 30,  9, 24,
   13, 18,  8, 12,  7,  6,  5, 63
};

// KNUTH'S 2-ADIC FUNCTIONS, FOR FAST popcount()
const uint64_t K1 = (uint64_t)(0x5555555555555555); /*  -1/3   */
const uint64_t K2 = (uint64_t)(0x3333333333333333); /*  -1/5   */
const uint64_t K4 = (uint64_t)(0x0f0f0f0f0f0f0f0f); /*  -1/17  */
const uint64_t KF = (uint64_t)(0x0101010101010101); /*  -1/255 */


uint64_t SQUARE_BBS[64];
uint64_t KNIGHT_ATTACKS[64];
uint64_t KING_ATTACKS[64];
uint64_t** RAY_ATTACK_ARRAYS;
int PIECE_VALUES[14];
int PIECE_VALUES_ABS[14];
int PIECE_SQUARE_VALUES[14][64];
const int MOBILITY_FACTOR = 1;
const int SAFETY_FACTOR = 2;

typedef struct {
	unsigned int plyCount : 15;
	unsigned int castlingFlags : 4;
	unsigned int enPassantFlag : 6; // Square of capturable pawn
} IrrFlag;

typedef struct {
	IrrFlag* list;
	int used;
	int size;
} IrrFlagStack;

typedef struct {
	uint64_t pieceBB[14];
	uint64_t emptyBB;
	uint64_t occupiedBB;
	unsigned int player : 1;
	IrrFlag flag;
	signed int squareValueTotal;
	signed int materialCount;
	uint64_t squareAttacksBB[64];
	// unsigned char attackedBySide[128];
} Position;


typedef struct {
	unsigned int from : 6;
	unsigned int to : 6;
	unsigned int flags : 16;
	unsigned int piece : 4;
	unsigned int colour : 1;
	unsigned int cPiece : 4;
	unsigned int cColour : 1;
} Move;

typedef struct {
	Move* list;
	int used;
	int size;
} MoveList;

uint64_t getPieceBB(Position*, int);
uint64_t getEmptyBB(Position*);
uint64_t getOccupiedBB(Position*);
void outputBitBoard(uint64_t);
void outputPosition(Position*);
void outputAttackMaps(Position*);
char rankToChar(int);
char pieceToChar(int);
int abs(int);
int serialiseBoard(int*, uint64_t);
uint64_t positiveRayAttacks(uint64_t, int, int);
uint64_t negativeRayAttacks(uint64_t, int, int);
int bitScanForward(uint64_t);
int bitScanReverse(uint64_t);
int attackedByWhite(Position*, uint64_t);
int attackedByBlack(Position*, uint64_t);
uint64_t attackedByWhiteBitBoard(Position*, uint64_t);
uint64_t attackedByBlackBitBoard(Position*, uint64_t);
int popCount(uint64_t);

void initGlobalArrays() {
	SQUARE_BBS[A1_INT] = A1;
	SQUARE_BBS[B1_INT] = B1;
	SQUARE_BBS[C1_INT] = C1;
	SQUARE_BBS[D1_INT] = D1;
	SQUARE_BBS[E1_INT] = E1;
	SQUARE_BBS[F1_INT] = F1;
	SQUARE_BBS[G1_INT] = G1;
	SQUARE_BBS[H1_INT] = H1;
	SQUARE_BBS[A2_INT] = A2;
	SQUARE_BBS[B2_INT] = B2;
	SQUARE_BBS[C2_INT] = C2;
	SQUARE_BBS[D2_INT] = D2;
	SQUARE_BBS[E2_INT] = E2;
	SQUARE_BBS[F2_INT] = F2;
	SQUARE_BBS[G2_INT] = G2;
	SQUARE_BBS[H2_INT] = H2;
	SQUARE_BBS[A3_INT] = A3;
	SQUARE_BBS[B3_INT] = B3;
	SQUARE_BBS[C3_INT] = C3;
	SQUARE_BBS[D3_INT] = D3;
	SQUARE_BBS[E3_INT] = E3;
	SQUARE_BBS[F3_INT] = F3;
	SQUARE_BBS[G3_INT] = G3;
	SQUARE_BBS[H3_INT] = H3;
	SQUARE_BBS[A4_INT] = A4;
	SQUARE_BBS[B4_INT] = B4;
	SQUARE_BBS[C4_INT] = C4;
	SQUARE_BBS[D4_INT] = D4;
	SQUARE_BBS[E4_INT] = E4;
	SQUARE_BBS[F4_INT] = F4;
	SQUARE_BBS[G4_INT] = G4;
	SQUARE_BBS[H4_INT] = H4;
	SQUARE_BBS[A5_INT] = A5;
	SQUARE_BBS[B5_INT] = B5;
	SQUARE_BBS[C5_INT] = C5;
	SQUARE_BBS[D5_INT] = D5;
	SQUARE_BBS[E5_INT] = E5;
	SQUARE_BBS[F5_INT] = F5;
	SQUARE_BBS[G5_INT] = G5;
	SQUARE_BBS[H5_INT] = H5;
	SQUARE_BBS[A6_INT] = A6;
	SQUARE_BBS[B6_INT] = B6;
	SQUARE_BBS[C6_INT] = C6;
	SQUARE_BBS[D6_INT] = D6;
	SQUARE_BBS[E6_INT] = E6;
	SQUARE_BBS[F6_INT] = F6;
	SQUARE_BBS[G6_INT] = G6;
	SQUARE_BBS[H6_INT] = H6;
	SQUARE_BBS[A7_INT] = A7;
	SQUARE_BBS[B7_INT] = B7;
	SQUARE_BBS[C7_INT] = C7;
	SQUARE_BBS[D7_INT] = D7;
	SQUARE_BBS[E7_INT] = E7;
	SQUARE_BBS[F7_INT] = F7;
	SQUARE_BBS[G7_INT] = G7;
	SQUARE_BBS[H7_INT] = H7;
	SQUARE_BBS[A8_INT] = A8;
	SQUARE_BBS[B8_INT] = B8;
	SQUARE_BBS[C8_INT] = C8;
	SQUARE_BBS[D8_INT] = D8;
	SQUARE_BBS[E8_INT] = E8;
	SQUARE_BBS[F8_INT] = F8;
	SQUARE_BBS[G8_INT] = G8;
	SQUARE_BBS[H8_INT] = H8;

	int knightJumps[8] = {-21,-19,-12,-8,8,12,19,21};
	int i,j,dest;
	uint64_t attackBB;
	for(j=0; j<64; j++) {
		attackBB = 0;
		for(i=0; i<8; i++) {
			dest = MAILBOX120[MAILBOX64[j] + knightJumps[i]];
			if(dest >= 0) {
				attackBB |= SQUARE_BBS[dest];
			}
		}
		KNIGHT_ATTACKS[j] = attackBB;
	}

	int kingJumps[8] = {-11,-10,-9,-1,1,9,10,11};
	for(j=0; j<64; j++) {
		attackBB = 0;
		for(i=0; i<8; i++) {
			dest = MAILBOX120[MAILBOX64[j] + kingJumps[i]];
			if(dest >= 0) {
				attackBB |= SQUARE_BBS[dest];
			}
		}
		KING_ATTACKS[j] = attackBB;
	}

	RAY_ATTACK_ARRAYS = (uint64_t**) malloc(8*sizeof(uint64_t));
	for(i=0; i<8; i++) {
		RAY_ATTACK_ARRAYS[i] = (uint64_t*) malloc(64 * sizeof(uint64_t));
	}

	int ray_dirs[8] = {8, 1, 7, 9, -8, -1, -7, -9};
	int dir, square, toSquare, file, rank, toFile, toRank, steps;
	uint64_t board;
	for(dir=0; dir<8; dir++) {
		for(square=0; square<64; square++) {
			board = 0;
			file = square % 8;
			rank = square / 8;
			for(steps=1; steps<8; steps++) {
				toSquare = square + (steps * ray_dirs[dir]);
				if((toSquare < 0) || (toSquare > 63)) {
					break;
				}
				toFile = toSquare % 8;
				toRank = toSquare / 8;
				if((abs(file - toFile) >= 7) || (abs(rank - toRank) >= 7)) {
					break;
				}
				file = toFile;
				rank = toRank;
				board |= SQUARE_BBS[toSquare];
			}
			RAY_ATTACK_ARRAYS[dir][square] = board;
		}
	}

	PIECE_VALUES[WHITE] = 0;
	PIECE_VALUES[BLACK] = 0;
	PIECE_VALUES[W_PAWN] = 100;
	PIECE_VALUES[W_KNIGHT] = 300;
	PIECE_VALUES[W_BISHOP] = 325;
	PIECE_VALUES[W_ROOK] = 500;
	PIECE_VALUES[W_QUEEN] = 900;
	PIECE_VALUES[W_KING] = 0;
	for(i=0; i<B_PAWN; i++) {
		PIECE_VALUES_ABS[i] = PIECE_VALUES[i];
	}
	// Define black values symetrically
	for(i=B_PAWN; i<=B_KING; i++) {
		PIECE_VALUES[i] = -PIECE_VALUES[i-6];
		PIECE_VALUES_ABS[i] = PIECE_VALUES[i-6];
	}

	for(i=0; i<14; i++) {
		for(square=0; square<64; square++) {
			PIECE_SQUARE_VALUES[i][square] = 0;
		}
	}

	for(square=0; square<=64; square++) {
		board = SQUARE_BBS[square];
		if(board & CENTRE_SQUARES) {
			// Pawns best occupying centre
			PIECE_SQUARE_VALUES[W_PAWN][square] += 20;
			PIECE_SQUARE_VALUES[B_PAWN][square] += -20;
		} else if(board & BIG_CENTRE_SQUARES) {
			PIECE_SQUARE_VALUES[W_PAWN][square] += 5;
			PIECE_SQUARE_VALUES[B_PAWN][square] += -5;
			PIECE_SQUARE_VALUES[W_KNIGHT][square] += 10;
			PIECE_SQUARE_VALUES[B_KNIGHT][square] += -10;
			// Optimal squares for knights
			if(square / 8 == 5) {
				PIECE_SQUARE_VALUES[W_KNIGHT][square] += 10;
			} else if(square / 8 == 2) {
				PIECE_SQUARE_VALUES[B_KNIGHT][square] += -10;
			}
		} else if(board & EDGE_SQUARES) {
			// Stop running king up board! (TODO: kingsafety())
			PIECE_SQUARE_VALUES[W_KING][square] += 50;
			PIECE_SQUARE_VALUES[B_KING][square] += -50;
			// Knight on the rim is dim
			PIECE_SQUARE_VALUES[W_KNIGHT][square] += -30;
			PIECE_SQUARE_VALUES[B_KNIGHT][square] += 30;
			PIECE_SQUARE_VALUES[W_BISHOP][square] += -15;
			PIECE_SQUARE_VALUES[B_BISHOP][square] += 15;
			PIECE_SQUARE_VALUES[W_QUEEN][square] += -5;
			PIECE_SQUARE_VALUES[B_QUEEN][square] += 5;
		}
		// Pawns gain value on 6th/7th ranks
		switch(square / 8) {
			case 1:
				PIECE_SQUARE_VALUES[W_PAWN][square] += 0;
				PIECE_SQUARE_VALUES[B_PAWN][square] += -40; break;
			case 2:
				PIECE_SQUARE_VALUES[W_PAWN][square] += 0;
				PIECE_SQUARE_VALUES[B_PAWN][square] += -15; break;
			case 3:
				PIECE_SQUARE_VALUES[W_PAWN][square] += 2;
				PIECE_SQUARE_VALUES[B_PAWN][square] += -5; break;
			case 4:
				PIECE_SQUARE_VALUES[W_PAWN][square] += 5;
				PIECE_SQUARE_VALUES[B_PAWN][square] += -2; break;
			case 5:
				PIECE_SQUARE_VALUES[W_PAWN][square] += 15;
				PIECE_SQUARE_VALUES[B_PAWN][square] += 0; break;
			case 6:
				PIECE_SQUARE_VALUES[W_PAWN][square] += 40;
				PIECE_SQUARE_VALUES[B_PAWN][square] += 0; break;
		}
		switch(square % 8) {
			case 0:
			case 7:
				PIECE_SQUARE_VALUES[W_PAWN][square] += -10;
				PIECE_SQUARE_VALUES[B_PAWN][square] += 10;
		}
	}
	PIECE_SQUARE_VALUES[W_PAWN][F2_INT] = 10;
	PIECE_SQUARE_VALUES[B_PAWN][F7_INT] = -10;
	PIECE_SQUARE_VALUES[W_PAWN][E2_INT] = -20;
	PIECE_SQUARE_VALUES[B_PAWN][E7_INT] = 20;
	PIECE_SQUARE_VALUES[W_PAWN][D2_INT] = -20;
	PIECE_SQUARE_VALUES[B_PAWN][D7_INT] = 20;

}

void freeGlobalArrays() {
	free(RAY_ATTACK_ARRAYS);
}

/**
 * bitScanForward
 * @author Martin Läuter (1997)
 *         Charles E. Leiserson
 *         Harald Prokop
 *         Keith H. Randall
 * "Using de Bruijn Sequences to Index a 1 in a Computer Word"
 * @param bb bitboard to scan
 * @precondition bb != 0
 * @return index (0..63) of least significant one bit
 */
int bitScanForward(uint64_t bb) {
   const uint64_t debruijn64 = (uint64_t)(0x03f79d71b4cb0a89);
   return DEBRUIJN_TABLE[((bb & -bb) * debruijn64) >> 58];
}

int bitScanReverse(uint64_t bb) {
   const uint64_t debruijn64 = (uint64_t)(0x03f79d71b4cb0a89);
	 bb |= bb >> 1;
   bb |= bb >> 2;
   bb |= bb >> 4;
   bb |= bb >> 8;
   bb |= bb >> 16;
   bb |= bb >> 32;
   return REVERSE_DEBRUIJN_TABLE[(bb * debruijn64) >> 58];
}

/**
 * @author: Donald Knuth
 * (The Art of Computer Programming)
 */
int popCount(uint64_t x) {
	x =  x - ((x >> 1)  & K1); /* put count of each 2 bits into those 2 bits */
  x = (x & K2) + ((x >> 2)  & K2); /* put count of each 4 bits into those 4 bits */
  x = (x +  (x >> 4)) & K4 ; /* put count of each 8 bits into those 8 bits */
  x = (x * KF) >> 56; /* returns 8 most significant bits of x + (x<<8) + (x<<16) + (x<<24) + ...  */
  return (int) x;
}


void initIrrFlagStack(IrrFlagStack* fs, int initSize) {
	fs->list = malloc(initSize * sizeof(IrrFlag));
	if(fs->list == NULL) {
		printf("ERROR: MALLOC FAILED\n"); return;
	}
	fs->used = 0;
	fs->size = initSize;
}

void pushIrrFlagStack(IrrFlagStack* fs, Position* p) {
	if(fs->used == fs->size) {
		fs->size *= 2;
		fs->list = realloc(fs->list, fs->size * sizeof(IrrFlag));
		if(fs->list == NULL) {
			printf("ERROR: REALLOC FAILED\n"); return;
		}
	}
	fs->list[fs->used++] = p->flag;
}

// Push another IrrFlag to fs, expanding as needed
void pushIrrFlagStackReference(IrrFlagStack* fs, IrrFlag* b) {
	if(fs->used == fs->size) {
		fs->size *= 2;
		fs->list = realloc(fs->list, fs->size * sizeof(IrrFlag));
		if(fs->list == NULL) {
			printf("ERROR: REALLOC FAILED\n"); return;
		}
	}
	fs->list[fs->used++] = *b;
}

// Remove and return IrrFlag from top of fs
IrrFlag popIrrFlagStack(IrrFlagStack* fs) {
	if(fs->used == 0) {
		IrrFlag f;
		printf("ERROR: EMPTY STACK"); return f;
	}
	return fs->list[--(fs->used)];
}

// Reset fs, freeing memory
void freeIrrFlagStack(IrrFlagStack* fs) {
	free(fs->list);
	fs->list = NULL;
	fs->used = fs->size = 0;
}

void initMoveList(MoveList* ml, int initSize) {
	ml->list = malloc(initSize * sizeof(Move));
	if(ml->list == NULL) {
		printf("ERROR: MALLOC FAILED\n"); return;
	}
	ml->used = 0;
	ml->size = initSize;
}

// Add another Move to ml, expanding as needed
void insertMoveList(MoveList* ml, Move m) {
	if(ml->used == ml->size) {
		ml->size *= 2;
		ml->list = realloc(ml->list, ml->size * sizeof(Move));
		if(ml->list == NULL) {
			printf("ERROR: REALLOC FAILED\n"); return;
		}
	}
	ml->list[ml->used++] = m;
}

// Add another Move to ml, expanding as needed
void insertMoveListReference(MoveList* ml, Move* m) {
	if(ml->used == ml->size) {
		ml->size *= 2;
		ml->list = realloc(ml->list, ml->size * sizeof(Move));
		if(ml->list == NULL) {
			printf("ERROR: REALLOC FAILED\n"); return;
		}
	}
	ml->list[ml->used++] = *m;
}

Move* popMoveList(MoveList* ml) {
	if(ml->used == 0) {
		printf("ERROR: EMPTY STACK"); return NULL;
	}
	return &(ml->list[--(ml->used)]);
}

void pushMoveList(MoveList* ml, int from, int to, int flags, int piece, int colour, int cPiece, int cColour) {
	Move m;
	m.from = from;
	m.to = to;
	m.flags = flags;
	m.piece = piece;
	m.colour = colour;
	m.cPiece = cPiece;
	m.cColour = cColour;
	if(ml->used == ml->size) {
		ml->size *= 2;
		ml->list = realloc(ml->list, ml->size * sizeof(Move));
		if(ml->list == NULL) {
			printf("ERROR: REALLOC FAILED\n"); return;
		}
	}
	ml->list[ml->used++] = m;
}

int abs(int x) {
	return (x >= 0) ? x : -x;
}
char fileNumToChar(int f) {
	return 'a' + f;
}
char rankNumToChar(int r) {
	return '1' + r;
}
void indexToAlgebraic(char* s, int ind) {
	int file = ind % 8;
	int rank = ind / 8;
	s[0] = fileNumToChar(file);
	s[1] = rankNumToChar(rank);
}
char playerToChar(int player) {
	return (player == WHITE) ? 'W' : 'b';
}
int squareToRank(int square) {
	return square & 7;
}
int squareToFile(int square) {
	return square >> 3;
}
char pieceToChar(int piece) {
	switch(piece) {
		case W_PAWN:
			return 'P';
		case W_KNIGHT:
			return 'N';
		case W_BISHOP:
			return 'B';
		case W_ROOK:
			return 'R';
		case W_QUEEN:
			return 'Q';
		case W_KING:
			return 'K';
		case B_PAWN:
			return 'p';
		case B_KNIGHT:
			return 'n';
		case B_BISHOP:
			return 'b';
		case B_ROOK:
			return 'r';
		case B_QUEEN:
			return 'q';
		case B_KING:
			return 'k';
		default:
			return '-';
	}
}

void moveToString(char* s, Move* m) {
	indexToAlgebraic(s, m->from);
	indexToAlgebraic(&s[2], m->to);
}

void outputMove(Move* m, int full) {
	char s[4];
	moveToString(s, m);
	printf("%c%c%c%c", s[0], s[1], s[2], s[3]);
	if(full) {
		printf("flags : %d\n",m->flags);
		printf("piece : %c\n",pieceToChar(m->piece));
		printf("colour : %c\n",playerToChar(m->colour));
		printf("cPiece : %c\n",pieceToChar(m->cPiece));
		printf("cColour : %c\n",playerToChar(m->cColour));
	}

}

void outputMoveList(MoveList* ml, char sep, int full) {
	int i;
	Move m;
	for(i=0; i<ml->used; i++) {
		if((i>0)&&(i % 10 == 0) && (sep != '\n')) {
			printf("\n");
		}
		m = ml->list[i];
		printf("%2d:",i+1);
		outputMove(&m, full);
		printf("%c",sep);

	}
}

// Reset ml, freeing memory
void freeMoveList(MoveList* ml) {
	free(ml->list);
	ml->list = NULL;
	ml->used = ml->size = 0;
}

uint64_t getPieceBB(Position* pos, int p) {
	return pos->pieceBB[p];
}
uint64_t getEmptyBB(Position* pos) {
	return pos->emptyBB;
}
uint64_t getOccupiedBB(Position* pos) {
	return pos->occupiedBB;
}
void genColourBBs(Position* pos) {
	pos->pieceBB[WHITE] = 0;
	int i;
	for(i=W_PAWN; i<=W_KING; i++) {
		pos->pieceBB[WHITE] |= pos->pieceBB[i];
	}
	pos->pieceBB[BLACK] = 0;
	for(i=B_PAWN; i<=B_KING; i++) {
		pos->pieceBB[BLACK] |= pos->pieceBB[i];
	}
}
void genOcccupied(Position* pos) {
	pos->occupiedBB = pos->pieceBB[WHITE] | pos->pieceBB[BLACK];
	pos->emptyBB = ~pos->occupiedBB;
}
void setSquare(Position* pos, uint64_t square, int piece) {
	pos->pieceBB[piece] |= square;
}


void outputBitBoard(uint64_t bb) {
	int rankNum, bit;
	uint64_t rank;
	printf("\n");
	for(rankNum = 7; rankNum>=0; rankNum--) {
		printf("%c",rankNumToChar(rankNum));
		rank = (bb >> (rankNum*8)) & 255;
		for(bit=0; bit<8; bit++) {
			if(rank&(ONE64BIT<<bit)) {
				printf("X");
			} else {
				printf("-");
			}
		}
		printf("\n");
	}
	printf(" abcdefgh\n");

}

void outputAttackCounts(unsigned char* counts) {
	int i;
	for(i=0; i<128; i++) {
		printf("%02d ", (int) counts[i]);
		if(i%8==7) {
			printf("\n");
		}
		if(i==63) {
			printf("\n\n");
		}
	}
	printf("\n");
}

void outputMeta(Position* p) {
	outputBitBoard(getPieceBB(p, WHITE));
	outputBitBoard(getPieceBB(p, BLACK));
	outputBitBoard(getOccupiedBB(p));
	outputBitBoard(getEmptyBB(p));
}

void outputIrrFlag(IrrFlag flag) {
	if(flag.castlingFlags&W_KSIDE_CASTLE) {
		printf("K");
	} else {
		printf("-");
	}
	if(flag.castlingFlags&W_QSIDE_CASTLE) {
		printf("Q");
	} else {
		printf("-");
	}
	if(flag.castlingFlags&B_KSIDE_CASTLE) {
		printf("k");
	} else {
		printf("-");
	}
	if(flag.castlingFlags&B_QSIDE_CASTLE) {
		printf("q");
	} else {
		printf("-");
	}
	printf(" e.p.=%d ply=%d\n", flag.enPassantFlag, flag.plyCount);
}

void outputPosition(Position* p) {
	int piece, rank, squareNum, filled;
	uint64_t square;
	printf("\n");
	for(rank=7; rank>=0; rank--) {
		for(squareNum=rank*8; squareNum<(rank*8)+8; squareNum++) {
			if(squareNum % 8 == 0) {
				printf("|%c",rankNumToChar(squareNum/8));
			}
			filled = FALSE;
			square = (ONE64BIT << squareNum);
			for(piece=2; piece<14; piece++) {
				if(p->pieceBB[piece] & square) {
					printf("|%c", pieceToChar(piece));
					filled = TRUE; break;
				}
			}
			if(!filled) {
				printf("|.");
			}
			if(squareNum % 8 == 7) {
				printf("\n");
			}
		}
	}
	printf(" %c", playerToChar(p->player));
	printf("|a|b|c|d|e|f|g|h\n");
	outputIrrFlag(p->flag);
	printf("Material:%d Square vals:%d\n", p->materialCount, p->squareValueTotal);
	// outputMeta(p);
}

void outputAttackMaps(Position* p) {
	char square[2];
	char* ptr = &square[0];
	for(int i=0; i<64; i++) {
		indexToAlgebraic(ptr, i);
		printf("Square: %c%c\n",square[0], square[1]);
		outputBitBoard(p->squareAttacksBB[i]);
	}
}

void initialisePosition(Position* p) {
	int i;
	for(i=0; i<14; i++) {
		p->pieceBB[i] = 0;
	}
	p->emptyBB = 0;
	p->occupiedBB = 0;

	p->squareValueTotal = 0;
	// }
	p->materialCount = 0;
	for(i=0; i<64; i++) {
		p->squareAttacksBB[i] = 0;
		// p->attackedBySide[i] = 0;
		// p->attackedBySide[i+64] = 0;
	}
}

// Slow
int pieceOnSquare(Position* p, int square) {
	int i;
	uint64_t squareBB = SQUARE_BBS[square];
	for(i=W_PAWN; i<=B_KING; i++) {
		if(p->pieceBB[i] & squareBB) {
			return i;
		}
	}
	if(p->emptyBB & squareBB) {
		return 0;
	}
	return -1;
}

uint64_t whitePawnAttacks(int square) {
	switch(square % 8) {
		case 0:
			return SQUARE_BBS[square + 9];
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			return SQUARE_BBS[square + 9] | SQUARE_BBS[square + 7];
		case 7:
			return SQUARE_BBS[square + 7];
	}
	return 0;
}
uint64_t bishopAttacks(Position* p, int from) {
	uint64_t attackedSquares = 0;
	attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_NW, from);
	attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_NE, from);
	attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_SE, from);
	attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_SW, from);
	return attackedSquares;
}
uint64_t rookAttacks(Position* p, int from) {
	uint64_t attackedSquares = 0;
	attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_N, from);
	attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_E, from);
	attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_S, from);
	attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_W, from);
	return attackedSquares;
}
uint64_t queenAttacks(Position* p, int from) {
	uint64_t attackedSquares = 0;
	int i;
	for(i=DIR_N; i<=DIR_NE; i++) {
		attackedSquares |= positiveRayAttacks(p->occupiedBB, i, from);
	}
	for(i=DIR_S; i<=DIR_SW; i++) {
		attackedSquares |= negativeRayAttacks(p->occupiedBB, i, from);
	}
	return attackedSquares;
}
uint64_t blackPawnAttacks(int square) {
	switch(square % 8) {
		case 0:
			return SQUARE_BBS[square - 7];
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			return SQUARE_BBS[square - 9] | SQUARE_BBS[square - 7];
		case 7:
			return SQUARE_BBS[square - 9];
	}
	return 0;
}

uint64_t pieceAttacks(Position* p, int piece, int square) {
	switch(piece) {
		case W_PAWN:
			return whitePawnAttacks(square);
		case B_PAWN:
			return blackPawnAttacks(square);
		case W_KNIGHT:
		case B_KNIGHT:
			return KNIGHT_ATTACKS[square];
		case W_BISHOP:
		case B_BISHOP:
			return bishopAttacks(p, square);
		case W_ROOK:
		case B_ROOK:
			return rookAttacks(p, square);
		case W_QUEEN:
		case B_QUEEN:
			return queenAttacks(p, square);
		case W_KING:
		case B_KING:
			return KING_ATTACKS[square];
		case 0:
			return 0;
		default:
			// Shouldn't occur. Fill everything for easy debugging
			return ~0;
	}
}

// void genAllSquareValues(Position* p) {
// 	int square, piece;
// 	for(square=0; square<64; square++) {
// 		piece = pieceOnSquare(p, square);
// 		p->squareValue[piece][square] = PIECE_SQUARE_VALUES[piece][square];
// 	}
// }

// Slow, only use once
void genAllAttackMaps(Position* p) {
	int square, piece, empty, colour;
	int i;
	for(square=0; square<64; square++) {
		piece = pieceOnSquare(p, square);
		empty = (p->emptyBB & SQUARE_BBS[square]) ? 2 : 0;
		colour = (p->pieceBB[WHITE] & SQUARE_BBS[square]) ? 1 : 0;
		colour += empty;
		p->squareAttacksBB[square] = pieceAttacks(p, piece, square);
	}
}

void setupStartPosition(Position* p) {
	initialisePosition(p);
	setSquare(p, A1, W_ROOK);
	setSquare(p, B1, W_KNIGHT);
	setSquare(p, C1, W_BISHOP);
	setSquare(p, D1, W_QUEEN);
	setSquare(p, E1, W_KING);
	setSquare(p, F1, W_BISHOP);
	setSquare(p, G1, W_KNIGHT);
	setSquare(p, H1, W_ROOK);

	setSquare(p, A8, B_ROOK);
	setSquare(p, B8, B_KNIGHT);
	setSquare(p, C8, B_BISHOP);
	setSquare(p, D8, B_QUEEN);
	setSquare(p, E8, B_KING);
	setSquare(p, F8, B_BISHOP);
	setSquare(p, G8, B_KNIGHT);
	setSquare(p, H8, B_ROOK);

	setSquare(p, A2, W_PAWN);
	setSquare(p, B2, W_PAWN);
	setSquare(p, C2, W_PAWN);
	setSquare(p, D2, W_PAWN);
	setSquare(p, E2, W_PAWN);
	setSquare(p, F2, W_PAWN);
	setSquare(p, G2, W_PAWN);
	setSquare(p, H2, W_PAWN);

	setSquare(p, A7, B_PAWN);
	setSquare(p, B7, B_PAWN);
	setSquare(p, C7, B_PAWN);
	setSquare(p, D7, B_PAWN);
	setSquare(p, E7, B_PAWN);
	setSquare(p, F7, B_PAWN);
	setSquare(p, G7, B_PAWN);
	setSquare(p, H7, B_PAWN);

	genColourBBs(p);
	genOcccupied(p);
	// genAllSquareValues(p);

	p->materialCount = 0;
	p->squareValueTotal = 0;
	p->player = WHITE;
	p->flag.plyCount = 0;
	p->flag.castlingFlags = W_KSIDE_CASTLE | W_QSIDE_CASTLE | B_KSIDE_CASTLE | B_QSIDE_CASTLE;
	p->flag.enPassantFlag = 0;
}

Move createMove(int from, int to, int flags, int piece, int colour, int cPiece, int cColour) {
	Move m;
	m.from = from;
	m.to = to;
	m.flags = flags;
	m.piece = piece;
	m.colour = colour;
	m.cPiece = cPiece;
	m.cColour = cColour;
	return m;
}

void makeMove(Position* p, Move* m, IrrFlagStack* fs) {
	pushIrrFlagStack(fs, p);
	p->player = !p->player;
	uint64_t fromBB = SQUARE_BBS[m->from];
	uint64_t toBB = SQUARE_BBS[m->to];
	uint64_t fromToBB = fromBB ^ toBB;
	uint64_t specialBB;

	switch(m->flags) {
		case FLAG_QUIET_MOVE:
			p->pieceBB[m->piece] 		^= fromToBB;
			p->pieceBB[m->colour] 	^= fromToBB;
			p->occupiedBB 					^= fromToBB;
			p->emptyBB							^= fromToBB;
			p->flag.plyCount++; // Reversible move
			p->flag.enPassantFlag = 0;
			p->squareValueTotal += PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->piece, m->to);
			// p->attackedBySide[(64*m->colour)+m->from]
			break;
		case FLAG_PAWN_PUSH:
			p->pieceBB[m->piece] 		^= fromToBB;
			p->pieceBB[m->colour] 	^= fromToBB;
			p->occupiedBB 					^= fromToBB;
			p->emptyBB							^= fromToBB;
			p->flag.plyCount = 0;
			p->flag.enPassantFlag = 0;
			p->squareValueTotal += PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->piece, m->to);
			break;
		case FLAG_DOUBLE_PAWN_PUSH:
			p->pieceBB[m->piece] 		^= fromToBB;
			p->pieceBB[m->colour] 	^= fromToBB;
			p->occupiedBB 					^= fromToBB;
			p->emptyBB							^= fromToBB;
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->piece, m->to);
			// En passant flag
			p->flag.enPassantFlag = m->to;
			p->flag.plyCount = 0;
			p->squareValueTotal += PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			break;
		case FLAG_CAPTURES:
			p->pieceBB[m->piece] 		^= fromToBB;
			p->pieceBB[m->colour] 	^= fromToBB;
			p->pieceBB[m->cPiece] 	^= toBB;
			p->pieceBB[m->cColour] 	^= toBB;
			p->occupiedBB 					^= fromBB;
			p->emptyBB							^= fromBB;
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->piece, m->to);
			p->flag.plyCount = 0;
			p->flag.enPassantFlag = 0;
			p->squareValueTotal += PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->materialCount -= PIECE_VALUES[m->cPiece];
			break;
		case FLAG_EP_CAPTURE:
			// printf("%d\n", p->flag.enPassantFlag);
			specialBB = (SQUARE_BBS[p->flag.enPassantFlag]);

			p->pieceBB[m->piece] 		^= fromToBB;
			p->pieceBB[m->colour] 	^= fromToBB;
			p->pieceBB[m->cPiece] 	^= specialBB;
			p->pieceBB[m->cColour] 	^= specialBB;
			p->occupiedBB 					^= (fromToBB | specialBB);
			p->emptyBB							^= (fromToBB | specialBB);
			p->squareValueTotal += PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->squareValueTotal -= PIECE_SQUARE_VALUES[m->cPiece][p->flag.enPassantFlag];
			p->materialCount -= PIECE_VALUES[m->cPiece];
			// outputBitBoard(p->pieceBB[B_PAWN]);

			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[p->flag.enPassantFlag] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->piece, m->to);
			p->flag.plyCount = 0;
			p->flag.enPassantFlag = 0;
			break;
		case FLAG_KING_CASTLE:
			specialBB = (toBB>>1) | (toBB<<1); // F1/8 | H1/8
			p->pieceBB[m->piece] 	^= fromToBB; 	// Move king
			p->pieceBB[W_ROOK+(6*m->colour)] ^= specialBB;// Move rook
			p->pieceBB[m->colour] ^= (fromToBB | specialBB);
			p->occupiedBB ^= (fromToBB | specialBB);
			p->emptyBB		^= (fromToBB | specialBB);
			p->flag.castlingFlags &= ~((W_KSIDE_CASTLE|W_QSIDE_CASTLE)<<(2*m->colour));
			p->squareAttacksBB[m->from] = 0; // E1/8
			p->squareAttacksBB[m->from+1] = pieceAttacks(p, W_ROOK+(6*m->colour), m->to); // F1/F8
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->piece, m->to); // G1/G8
			p->squareAttacksBB[m->to+1] = 0; // H1/H8
			p->flag.plyCount++;
			p->flag.enPassantFlag = 0;
			p->squareValueTotal += PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->squareValueTotal += PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->from+1] - PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->to+1];
			break;
		case FLAG_QUEEN_CASTLE:
			specialBB = (toBB<<1) | (toBB>>2); // D1/8 | A1/8
			p->pieceBB[m->piece] 	^= fromToBB;
			p->pieceBB[W_ROOK+(6*m->colour)] ^= specialBB;
			p->pieceBB[m->colour] ^= (fromToBB | specialBB);
			p->occupiedBB ^= (fromToBB | specialBB);
			p->emptyBB		^= (fromToBB | specialBB);
			p->flag.castlingFlags &= ~((W_KSIDE_CASTLE|W_QSIDE_CASTLE)<<(2*m->colour));
			p->squareAttacksBB[m->from] = 0; // E1/8
			p->squareAttacksBB[m->from-1] = pieceAttacks(p, W_ROOK+(6*m->colour), m->to); // D1/D8
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->piece, m->to); // C1/C8
			p->squareAttacksBB[m->to-2] = 0; // A1/A8
			p->squareValueTotal += PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->squareValueTotal += PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->from-1] - PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->to-2];
			p->flag.plyCount++;
			p->flag.enPassantFlag = 0;
			break;
		case FLAG_KNIGHT_PROMO:
			p->pieceBB[m->piece] 	^= fromBB; // Pawn disappears
			p->pieceBB[W_KNIGHT+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->occupiedBB 				^= fromToBB;
			p->emptyBB						^= fromToBB;
			p->flag.plyCount = 0;
			p->flag.enPassantFlag = 0;
			p->squareValueTotal += PIECE_SQUARE_VALUES[W_KNIGHT+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, W_KNIGHT+(6*m->colour), m->to);
			break;
		case FLAG_BISHOP_PROMO:
			p->pieceBB[m->piece] 	^= fromBB; // Pawn disappears
			p->pieceBB[W_BISHOP+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->occupiedBB 				^= fromToBB;
			p->emptyBB						^= fromToBB;
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, W_BISHOP+(6*m->colour), m->to);
			p->squareValueTotal += PIECE_SQUARE_VALUES[W_BISHOP+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->flag.plyCount = 0;
			p->flag.enPassantFlag = 0;
			break;
		case FLAG_ROOK_PROMO:
			p->pieceBB[m->piece] 	^= fromBB; // Pawn disappears
			p->pieceBB[W_ROOK+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->occupiedBB 				^= fromToBB;
			p->emptyBB						^= fromToBB;
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, W_ROOK+(6*m->colour), m->to);
			p->squareValueTotal += PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->flag.plyCount = 0;
			p->flag.enPassantFlag = 0;
			break;
		case FLAG_QUEEN_PROMO:
			p->pieceBB[m->piece] 	^= fromBB; // Pawn disappears
			p->pieceBB[W_QUEEN+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->occupiedBB 				^= fromToBB;
			p->emptyBB						^= fromToBB;
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, W_QUEEN+(6*m->colour), m->to);
			p->squareValueTotal += PIECE_SQUARE_VALUES[W_QUEEN+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->flag.plyCount = 0;
			p->flag.enPassantFlag = 0;
			break;
		case FLAG_KNIGHT_PROMO_CAPT:
			p->pieceBB[m->piece] 	^= fromBB; // Pawn disappears
			p->pieceBB[W_KNIGHT+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->pieceBB[m->cPiece] 	^= toBB;
			p->pieceBB[m->cColour] 	^= toBB;
			p->occupiedBB 				^= fromBB;
			p->emptyBB						^= fromBB;
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, W_KNIGHT+(6*m->colour), m->to);
			p->squareValueTotal += PIECE_SQUARE_VALUES[W_KNIGHT+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->materialCount += PIECE_VALUES[W_KNIGHT+(6*m->colour)] - PIECE_VALUES[m->piece];
			p->flag.plyCount = 0;
			p->flag.enPassantFlag = 0;
			break;
		case FLAG_BISHOP_PROMO_CAPT:
			p->pieceBB[m->piece] 	^= fromBB; // Pawn disappears
			p->pieceBB[W_BISHOP+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->pieceBB[m->cPiece] 	^= toBB;
			p->pieceBB[m->cColour] 	^= toBB;
			p->occupiedBB 				^= fromBB;
			p->emptyBB						^= fromBB;
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, W_BISHOP+(6*m->colour), m->to);
			p->squareValueTotal += PIECE_SQUARE_VALUES[W_BISHOP+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->materialCount += PIECE_VALUES[W_BISHOP+(6*m->colour)] - PIECE_VALUES[m->piece];
			p->flag.plyCount = 0;
			p->flag.enPassantFlag = 0;
			break;
		case FLAG_ROOK_PROMO_CAPT:
			p->pieceBB[m->piece] 	^= fromBB; // Pawn disappears
			p->pieceBB[W_ROOK+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->pieceBB[m->cPiece] 	^= toBB;
			p->pieceBB[m->cColour] 	^= toBB;
			p->occupiedBB 				^= fromBB;
			p->emptyBB						^= fromBB;
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, W_ROOK+(6*m->colour), m->to);
			p->squareValueTotal += PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->materialCount += PIECE_VALUES[W_ROOK+(6*m->colour)] - PIECE_VALUES[m->piece];
			p->flag.plyCount = 0;
			p->flag.enPassantFlag = 0;
			break;
		case FLAG_QUEEN_PROMO_CAPT:
			p->pieceBB[m->piece] 	^= fromBB; // Pawn disappears
			p->pieceBB[W_QUEEN+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->pieceBB[m->cPiece] 	^= toBB;
			p->pieceBB[m->cColour] 	^= toBB;
			p->occupiedBB 				^= fromBB;
			p->emptyBB						^= fromBB;
			p->squareValueTotal += PIECE_SQUARE_VALUES[W_QUEEN+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->materialCount += PIECE_VALUES[W_QUEEN+(6*m->colour)] - PIECE_VALUES[m->piece];
			p->squareAttacksBB[m->from] = 0;
			p->squareAttacksBB[m->to] = pieceAttacks(p, W_QUEEN+(6*m->colour), m->to);
			p->flag.plyCount = 0;
			p->flag.enPassantFlag = 0;
			break;
	}
	// Test. (Need to consider every combination seperately?)
	switch(fromToBB & CASTLE_SQUARES) {
		case 0: break;
		case A1:
			p->flag.castlingFlags &= ~W_QSIDE_CASTLE; break;
		case H1:
			p->flag.castlingFlags &= ~W_KSIDE_CASTLE; break;
		case A8:
			p->flag.castlingFlags &= ~B_QSIDE_CASTLE; break;
		case H8:
			p->flag.castlingFlags &= ~B_KSIDE_CASTLE; break;
		case E1:
			p->flag.castlingFlags &= ~(W_QSIDE_CASTLE | W_KSIDE_CASTLE); break;
		case E8:
			p->flag.castlingFlags &= ~(B_QSIDE_CASTLE | B_KSIDE_CASTLE); break;
		case (A1 | A8):
			p->flag.castlingFlags &= ~(W_QSIDE_CASTLE | B_QSIDE_CASTLE); break;
		case (H1 | H8):
			p->flag.castlingFlags &= ~(W_KSIDE_CASTLE | B_KSIDE_CASTLE); break;
		case (A1 | H8):
			p->flag.castlingFlags &= ~(W_QSIDE_CASTLE | B_KSIDE_CASTLE); break;
		case (H1 | A8):
			p->flag.castlingFlags &= ~(W_KSIDE_CASTLE | B_QSIDE_CASTLE); break;
	}
}

void unmakeMove(Position* p, Move* m, IrrFlagStack* fs) {
	p->player = !p->player;
	p->flag = popIrrFlagStack(fs);
	uint64_t fromBB = SQUARE_BBS[m->from];
	uint64_t toBB = SQUARE_BBS[m->to];
	uint64_t fromToBB = fromBB ^ toBB;
	uint64_t specialBB;
	switch(m->flags) {
		case FLAG_QUIET_MOVE:
		case FLAG_PAWN_PUSH:
		case FLAG_DOUBLE_PAWN_PUSH:
			p->pieceBB[m->piece] 	^= fromToBB;
			p->pieceBB[m->colour] 	^= fromToBB;
			p->occupiedBB 					^= fromToBB;
			p->emptyBB							^= fromToBB;
			p->squareAttacksBB[m->to] = 0;
			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);
			p->squareValueTotal -= PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			break;
		case FLAG_CAPTURES:
			p->pieceBB[m->piece] 	^= fromToBB;
			p->pieceBB[m->colour] 	^= fromToBB;
			p->pieceBB[m->cPiece] 	^= toBB;
			p->pieceBB[m->cColour] 	^= toBB;
			p->occupiedBB 					^= fromBB;
			p->emptyBB							^= fromBB;
			p->squareValueTotal -= PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->materialCount += PIECE_VALUES[m->cPiece];
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->cPiece, m->to);
			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);
			break;
		case FLAG_EP_CAPTURE:
			specialBB = (SQUARE_BBS[p->flag.enPassantFlag]);
			p->pieceBB[m->piece] 		^= fromToBB;
			p->pieceBB[m->colour] 	^= fromToBB;
			p->pieceBB[m->cPiece] 	^= specialBB;
			p->pieceBB[m->cColour] 	^= specialBB;
			p->occupiedBB 					^= (fromToBB | specialBB);
			p->emptyBB							^= (fromToBB | specialBB);
			p->squareValueTotal -= PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->squareValueTotal += PIECE_SQUARE_VALUES[m->cPiece][p->flag.enPassantFlag];
			p->materialCount += PIECE_VALUES[m->cPiece];
			p->squareAttacksBB[m->to] = 0;
			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);
			p->squareAttacksBB[p->flag.enPassantFlag] = pieceAttacks(p, m->cPiece, m->to);
			break;
		case FLAG_KING_CASTLE:
			specialBB = (toBB>>1) | (toBB<<1); // F1/8 | H1/8
			p->pieceBB[m->piece] 	^= fromToBB; 	// Move king
			p->pieceBB[W_ROOK+(6*m->colour)] ^= specialBB;// Move rook
			p->pieceBB[m->colour] ^= (fromToBB | specialBB);
			p->occupiedBB ^= (fromToBB | specialBB);
			p->emptyBB		^= (fromToBB | specialBB);

			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);; // E1/8
			p->squareAttacksBB[m->from+1] = 0;// F1/F8
			p->squareAttacksBB[m->to] = 0; // G1/G8
			p->squareAttacksBB[m->to+1] = pieceAttacks(p, W_ROOK+(6*m->colour), m->to+1);  // H1/H8

			p->squareValueTotal -= PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->squareValueTotal -= PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->from+1] - PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->to+1];
			break;
		case FLAG_QUEEN_CASTLE:
			specialBB = (toBB<<1) | (toBB>>2); // D1/8 | A1/8
			p->pieceBB[m->piece] 	^= fromToBB;
			p->pieceBB[W_ROOK+(6*m->colour)] ^= specialBB;
			p->pieceBB[m->colour] ^= (fromToBB | specialBB);
			p->occupiedBB ^= (fromToBB | specialBB);
			p->emptyBB		^= (fromToBB | specialBB);

			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from); // C1/C8; // E1/8
			p->squareAttacksBB[m->from-1] = 0; // D1/D8
			p->squareAttacksBB[m->to] = 0;
			p->squareAttacksBB[m->to-2] = pieceAttacks(p, W_ROOK+(6*m->colour), m->to-2); // A1/A8

			p->squareValueTotal -= PIECE_SQUARE_VALUES[m->piece][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->squareValueTotal -= PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->from-1] - PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->to-2];

			break;
		case FLAG_KNIGHT_PROMO:
			p->pieceBB[m->piece] 	^= fromBB; // Pawn appears
			p->pieceBB[W_KNIGHT+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->occupiedBB 				^= fromToBB;
			p->emptyBB						^= fromToBB;

			p->squareAttacksBB[m->to] = 0;
			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);

			p->squareValueTotal -= PIECE_SQUARE_VALUES[W_KNIGHT+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			break;
		case FLAG_BISHOP_PROMO:
			p->pieceBB[m->piece] 	^= fromBB;
			p->pieceBB[W_BISHOP+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->occupiedBB 				^= fromToBB;
			p->emptyBB						^= fromToBB;

			p->squareAttacksBB[m->to] = 0;
			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);

			p->squareValueTotal -= PIECE_SQUARE_VALUES[W_BISHOP+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			break;
		case FLAG_ROOK_PROMO:
			p->pieceBB[m->piece] 	^= fromBB;
			p->pieceBB[W_ROOK+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->occupiedBB 				^= fromToBB;
			p->emptyBB						^= fromToBB;

			p->squareAttacksBB[m->to] = 0;
			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);

			p->squareValueTotal -= PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			break;
		case FLAG_QUEEN_PROMO:
			p->pieceBB[m->piece] 	^= fromBB;
			p->pieceBB[W_QUEEN+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->occupiedBB 				^= fromToBB;
			p->emptyBB						^= fromToBB;

			p->squareAttacksBB[m->to] = 0;
			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);

			p->squareValueTotal -= PIECE_SQUARE_VALUES[W_QUEEN+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			break;
		case FLAG_KNIGHT_PROMO_CAPT:
			p->pieceBB[m->piece] 	^= fromBB;
			p->pieceBB[W_KNIGHT+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->pieceBB[m->cPiece] 	^= toBB;
			p->pieceBB[m->cColour] 	^= toBB;
			p->occupiedBB 				^= fromBB;
			p->emptyBB						^= fromBB;

			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->cPiece, m->to);

			p->squareValueTotal -= PIECE_SQUARE_VALUES[W_KNIGHT+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->materialCount -= PIECE_VALUES[W_KNIGHT+(6*m->colour)] - PIECE_VALUES[m->piece];
			break;
		case FLAG_BISHOP_PROMO_CAPT:
			p->pieceBB[m->piece] 	^= fromBB;
			p->pieceBB[W_BISHOP+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->pieceBB[m->cPiece] 	^= toBB;
			p->pieceBB[m->cColour] 	^= toBB;
			p->occupiedBB 				^= fromBB;
			p->emptyBB						^= fromBB;

			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->cPiece, m->to);

			p->squareValueTotal -= PIECE_SQUARE_VALUES[W_BISHOP+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->materialCount -= PIECE_VALUES[W_BISHOP+(6*m->colour)] - PIECE_VALUES[m->piece];
			break;
		case FLAG_ROOK_PROMO_CAPT:
			p->pieceBB[m->piece] 	^= fromBB;
			p->pieceBB[W_ROOK+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->pieceBB[m->cPiece] 	^= toBB;
			p->pieceBB[m->cColour] 	^= toBB;
			p->occupiedBB 				^= fromBB;
			p->emptyBB						^= fromBB;

			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->cPiece, m->to);

			p->squareValueTotal -= PIECE_SQUARE_VALUES[W_ROOK+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->materialCount -= PIECE_VALUES[W_ROOK+(6*m->colour)] - PIECE_VALUES[m->piece];
			break;
		case FLAG_QUEEN_PROMO_CAPT:
			p->pieceBB[m->piece] 	^= fromBB;
			p->pieceBB[W_QUEEN+(6*m->colour)] 	^= toBB;
			p->pieceBB[m->colour] ^= fromToBB;
			p->pieceBB[m->cPiece] 	^= toBB;
			p->pieceBB[m->cColour] 	^= toBB;
			p->occupiedBB 				^= fromBB;
			p->emptyBB						^= fromBB;

			p->squareAttacksBB[m->from] = pieceAttacks(p, m->piece, m->from);
			p->squareAttacksBB[m->to] = pieceAttacks(p, m->cPiece, m->to);

			p->squareValueTotal -= PIECE_SQUARE_VALUES[W_QUEEN+(6*m->colour)][m->to] - PIECE_SQUARE_VALUES[m->piece][m->from];
			p->materialCount -= PIECE_VALUES[W_QUEEN+(6*m->colour)] - PIECE_VALUES[m->piece];
			break;
	}
}

int serialiseBoard(int* output, uint64_t pBB) {
	int pCount, pLSB, prevBit;
	pCount = prevBit = 0;
	if(pBB) do {
		pLSB = bitScanForward(pBB);
		prevBit = output[pCount++] = pLSB + prevBit;
		pBB >>= pLSB;
	} while(pBB &= (pBB)-1);
	return pCount;
}

// Based on https://www.chessprogramming.org/Classical_Approach
uint64_t positiveRayAttacks(uint64_t occupied, int direction, int square) {
	uint64_t attacks = RAY_ATTACK_ARRAYS[direction][square];
	uint64_t blocker = attacks & occupied;
	if(blocker) {
		square = bitScanForward(blocker);
		attacks ^= RAY_ATTACK_ARRAYS[direction][square];
	}
	return attacks;
}
uint64_t negativeRayAttacks(uint64_t occupied, int direction, int square) {
	uint64_t attacks = RAY_ATTACK_ARRAYS[direction][square];
	uint64_t blocker = attacks & occupied;
	if(blocker) {
		square = bitScanReverse(blocker);
		attacks ^= RAY_ATTACK_ARRAYS[direction][square];
	}
	return attacks;
}


void genWhiteKnightMoves(MoveList* ml, Position* p) {


	int knightLocs[10];
	int knightCount = serialiseBoard(knightLocs, p->pieceBB[W_KNIGHT]);

	int i, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;

	for(i=0; i<knightCount; i++) {
		from = knightLocs[i];
		attackedSquares = KNIGHT_ATTACKS[from];

		if(attackedSquares & p->pieceBB[BLACK]) {
			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[B_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KNIGHT, WHITE, B_QUEEN, BLACK);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[B_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KNIGHT, WHITE, B_ROOK, BLACK);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[B_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KNIGHT, WHITE, B_BISHOP, BLACK);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[B_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KNIGHT, WHITE, B_KNIGHT, BLACK);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[B_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KNIGHT, WHITE, B_PAWN, BLACK);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}

		quietMoves = attackedSquares & p->emptyBB;
		if(quietMoves) {
			prevBit = 0;
			do {
				to = bitScanForward(quietMoves);
				pushMoveList(ml, from, to+prevBit, FLAG_QUIET_MOVE, W_KNIGHT, WHITE, 0, 0);
				prevBit += to;
				quietMoves >>= to;
			} while(quietMoves &= (quietMoves)-1);
		}
	}
}

void genWhiteKnightCaptures(MoveList* ml, Position* p) {


	int knightLocs[10];
	int knightCount = serialiseBoard(knightLocs, p->pieceBB[W_KNIGHT]);

	int i, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen;

	for(i=0; i<knightCount; i++) {
		from = knightLocs[i];
		attackedSquares = KNIGHT_ATTACKS[from];

		if(attackedSquares & p->pieceBB[BLACK]) {
			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[B_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KNIGHT, WHITE, B_QUEEN, BLACK);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[B_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KNIGHT, WHITE, B_ROOK, BLACK);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[B_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KNIGHT, WHITE, B_BISHOP, BLACK);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[B_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KNIGHT, WHITE, B_KNIGHT, BLACK);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[B_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KNIGHT, WHITE, B_PAWN, BLACK);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}
	}
}

void genWhiteKingMoves(MoveList* ml, Position* p) {

	int from = LOG2(p->pieceBB[W_KING]);
	// serialiseBoard(&from,p->pieceBB[W_KING] , W_KING);

	int i, prevBit, to;
	uint64_t attackedSquares, dangerSquares, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;

	attackedSquares = KING_ATTACKS[from];
	// Bitboard of neighbouring squares attacked by black pieces
	dangerSquares = prevBit = 0;
	// Temporarily vanish king so it doesn't interfere
	p->occupiedBB	^= p->pieceBB[W_KING];
	p->emptyBB		^= p->pieceBB[W_KING];
	do {
		to = bitScanForward(attackedSquares);
		// outputBitBoard(SQUARE_BBS[to+prevBit]);
		dangerSquares |= attackedByBlackBitBoard(p, SQUARE_BBS[to+prevBit]);
		prevBit += to;
		attackedSquares >>= to;
	} while(attackedSquares &= (attackedSquares)-1);
	p->occupiedBB ^= p->pieceBB[W_KING];
	p->emptyBB		^= p->pieceBB[W_KING];

	attackedSquares = KING_ATTACKS[from] &~ dangerSquares;

	if(attackedSquares & p->pieceBB[BLACK]) {
		// Do we attack any black queens?
		bQueen = attackedSquares & p->pieceBB[B_QUEEN];
		if(bQueen) {
			prevBit = 0;
			do {
				to = bitScanForward(bQueen);
				// if(!attackedByBlack(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KING, WHITE, B_QUEEN, BLACK);
				// }
				prevBit += to;
				bQueen >>= to;
			} while(bQueen &= (bQueen)-1);
		}

		bRook = attackedSquares & p->pieceBB[B_ROOK];
		if(bRook) {
			prevBit = 0;
			do {
				to = bitScanForward(bRook);
				// if(!attackedByBlack(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KING, WHITE, B_ROOK, BLACK);
				// }
				prevBit += to;
				bRook >>= to;
			} while(bRook &= (bRook)-1);
		}

		bBishop = attackedSquares & p->pieceBB[B_BISHOP];
		if(bBishop) {
			prevBit = 0;
			do {
				to = bitScanForward(bBishop);
				// if(!attackedByBlack(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KING, WHITE, B_BISHOP, BLACK);
				// }
				prevBit += to;
				bBishop >>= to;
			} while(bBishop &= (bBishop)-1);
		}

		bKnight = attackedSquares & p->pieceBB[B_KNIGHT];
		if(bKnight) {
			prevBit = 0;
			do {
				to = bitScanForward(bKnight);
				// if(!attackedByBlack(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KING, WHITE, B_KNIGHT, BLACK);
				// }
				prevBit += to;
				bKnight >>= to;
			} while(bKnight &= (bKnight)-1);
		}

		bPawn = attackedSquares & p->pieceBB[B_PAWN];
		if(bPawn) {
			prevBit = 0;
			do {
				to = bitScanForward(bPawn);
				// if(!attackedByBlack(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KING, WHITE, B_PAWN, BLACK);
				// }
				prevBit += to;
				bPawn >>= to;
			} while(bPawn &= (bPawn)-1);
		}
	}

	quietMoves = attackedSquares & p->emptyBB;
	if(quietMoves) {
		prevBit = 0;
		do {
			to = bitScanForward(quietMoves);
			// if(!attackedByBlack(p, SQUARE_BBS[to+prevBit])) {
				pushMoveList(ml, from, to+prevBit, FLAG_QUIET_MOVE, W_KING, WHITE, 0, 0);
			// }
			prevBit += to;
			quietMoves >>= to;
		} while(quietMoves &= (quietMoves)-1);
	}

	if((p->flag.castlingFlags & W_KSIDE_CASTLE) && (p->emptyBB & F1) && (p->emptyBB & G1) && !(attackedByBlack(p, SQUARE_BBS[E1_INT])) && !(attackedByBlack(p, SQUARE_BBS[F1_INT])) && !(attackedByBlack(p, SQUARE_BBS[G1_INT]))) {
		pushMoveList(ml, E1_INT, G1_INT, FLAG_KING_CASTLE, W_KING, WHITE, 0, 0);
	}
	if((p->flag.castlingFlags & W_QSIDE_CASTLE) && (p->emptyBB & D1) && (p->emptyBB & C1) && (p->emptyBB & B1) && !(attackedByBlack(p, SQUARE_BBS[E1_INT])) && !(attackedByBlack(p, SQUARE_BBS[D1_INT])) && !(attackedByBlack(p, SQUARE_BBS[C1_INT]))) {
		pushMoveList(ml, E1_INT, C1_INT, FLAG_QUEEN_CASTLE, W_KING, WHITE, 0, 0);
	}
}

void genWhiteKingCaptures(MoveList* ml, Position* p) {
	int from = LOG2(p->pieceBB[W_KING]);
	// serialiseBoard(&from,p->pieceBB[W_KING] , W_KING);

	int i, prevBit, to;
	uint64_t attackedSquares, dangerSquares, bPawn, bKnight, bBishop, bRook, bQueen;

	attackedSquares = KING_ATTACKS[from];
	// Bitboard of neighbouring squares attacked by black pieces
	dangerSquares = prevBit = 0;
	// Temporarily vanish king so it doesn't interfere
	p->occupiedBB	^= p->pieceBB[W_KING];
	p->emptyBB		^= p->pieceBB[W_KING];
	do {
		to = bitScanForward(attackedSquares);
		// outputBitBoard(SQUARE_BBS[to+prevBit]);
		dangerSquares |= attackedByBlackBitBoard(p, SQUARE_BBS[to+prevBit]);
		prevBit += to;
		attackedSquares >>= to;
	} while(attackedSquares &= (attackedSquares)-1);
	p->occupiedBB ^= p->pieceBB[W_KING];
	p->emptyBB		^= p->pieceBB[W_KING];

	attackedSquares = KING_ATTACKS[from] &~ dangerSquares;

	if(attackedSquares & p->pieceBB[BLACK]) {
		// Do we attack any black queens?
		bQueen = attackedSquares & p->pieceBB[B_QUEEN];
		if(bQueen) {
			prevBit = 0;
			do {
				to = bitScanForward(bQueen);
				// if(!attackedByBlack(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KING, WHITE, B_QUEEN, BLACK);
				// }
				prevBit += to;
				bQueen >>= to;
			} while(bQueen &= (bQueen)-1);
		}

		bRook = attackedSquares & p->pieceBB[B_ROOK];
		if(bRook) {
			prevBit = 0;
			do {
				to = bitScanForward(bRook);
				// if(!attackedByBlack(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KING, WHITE, B_ROOK, BLACK);
				// }
				prevBit += to;
				bRook >>= to;
			} while(bRook &= (bRook)-1);
		}

		bBishop = attackedSquares & p->pieceBB[B_BISHOP];
		if(bBishop) {
			prevBit = 0;
			do {
				to = bitScanForward(bBishop);
				// if(!attackedByBlack(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KING, WHITE, B_BISHOP, BLACK);
				// }
				prevBit += to;
				bBishop >>= to;
			} while(bBishop &= (bBishop)-1);
		}

		bKnight = attackedSquares & p->pieceBB[B_KNIGHT];
		if(bKnight) {
			prevBit = 0;
			do {
				to = bitScanForward(bKnight);
				// if(!attackedByBlack(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KING, WHITE, B_KNIGHT, BLACK);
				// }
				prevBit += to;
				bKnight >>= to;
			} while(bKnight &= (bKnight)-1);
		}

		bPawn = attackedSquares & p->pieceBB[B_PAWN];
		if(bPawn) {
			prevBit = 0;
			do {
				to = bitScanForward(bPawn);
				// if(!attackedByBlack(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_KING, WHITE, B_PAWN, BLACK);
				// }
				prevBit += to;
				bPawn >>= to;
			} while(bPawn &= (bPawn)-1);
		}
	}
}

void genWhiteQueenMoves(MoveList* ml, Position* p) {
	int queenLocs[9];
	int queenCount = serialiseBoard(queenLocs, p->pieceBB[W_QUEEN]);

	int i, dir, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;

	for(i=0; i<queenCount; i++) {
		from = queenLocs[i];
		attackedSquares = 0;

		for(dir=DIR_N; dir<= DIR_NE; dir++) {
			attackedSquares |= positiveRayAttacks(p->occupiedBB, dir, from);
		}
		for(dir=DIR_S; dir<= DIR_SW; dir++) {
			attackedSquares |= negativeRayAttacks(p->occupiedBB, dir, from);
		}

		if(attackedSquares & p->pieceBB[BLACK]) {
			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[B_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_QUEEN, WHITE, B_QUEEN, BLACK);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[B_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_QUEEN, WHITE, B_ROOK, BLACK);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[B_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_QUEEN, WHITE, B_BISHOP, BLACK);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[B_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_QUEEN, WHITE, B_KNIGHT, BLACK);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[B_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_QUEEN, WHITE, B_PAWN, BLACK);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}

		quietMoves = attackedSquares & p->emptyBB;
		if(quietMoves) {
			prevBit = 0;
			do {
				to = bitScanForward(quietMoves);
				pushMoveList(ml, from, to+prevBit, FLAG_QUIET_MOVE, W_QUEEN, WHITE, 0, 0);
				prevBit += to;
				quietMoves >>= to;
			} while(quietMoves &= (quietMoves)-1);
		}
	}
}

void genWhiteQueenCaptures(MoveList* ml, Position* p) {
	int queenLocs[9];
	int queenCount = serialiseBoard(queenLocs, p->pieceBB[W_QUEEN]);

	int i, dir, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen;

	for(i=0; i<queenCount; i++) {
		from = queenLocs[i];
		attackedSquares = 0;

		for(dir=DIR_N; dir<= DIR_NE; dir++) {
			attackedSquares |= positiveRayAttacks(p->occupiedBB, dir, from);
		}
		for(dir=DIR_S; dir<= DIR_SW; dir++) {
			attackedSquares |= negativeRayAttacks(p->occupiedBB, dir, from);
		}

		if(attackedSquares & p->pieceBB[BLACK]) {

			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[B_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_QUEEN, WHITE, B_QUEEN, BLACK);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[B_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_QUEEN, WHITE, B_ROOK, BLACK);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[B_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_QUEEN, WHITE, B_BISHOP, BLACK);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[B_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_QUEEN, WHITE, B_KNIGHT, BLACK);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[B_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_QUEEN, WHITE, B_PAWN, BLACK);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}
	}
}

void genWhiteRookMoves(MoveList* ml, Position* p) {

	int rookLocs[10];
	int rookCount = serialiseBoard(rookLocs, p->pieceBB[W_ROOK]);

	int i, dir, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;


	for(i=0; i<rookCount; i++) {
		from = rookLocs[i];
		attackedSquares = 0;

		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_N, from);
		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_E, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_S, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_W, from);

		if(attackedSquares & p->pieceBB[BLACK]) {
			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[B_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_ROOK, WHITE, B_QUEEN, BLACK);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[B_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_ROOK, WHITE, B_ROOK, BLACK);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[B_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_ROOK, WHITE, B_BISHOP, BLACK);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[B_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_ROOK, WHITE, B_KNIGHT, BLACK);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[B_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_ROOK, WHITE, B_PAWN, BLACK);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}

		quietMoves = attackedSquares & p->emptyBB;
		if(quietMoves) {
			prevBit = 0;
			do {
				to = bitScanForward(quietMoves);
				pushMoveList(ml, from, to+prevBit, FLAG_QUIET_MOVE, W_ROOK, WHITE, 0, 0);
				prevBit += to;
				quietMoves >>= to;
			} while(quietMoves &= (quietMoves)-1);
		}
	}
}

void genWhiteRookCaptures(MoveList* ml, Position* p) {
	int rookLocs[10];
	int rookCount = serialiseBoard(rookLocs, p->pieceBB[W_ROOK]);

	int i, dir, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen;


	for(i=0; i<rookCount; i++) {
		from = rookLocs[i];
		attackedSquares = 0;

		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_N, from);
		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_E, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_S, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_W, from);

		if(attackedSquares & p->pieceBB[BLACK]) {
			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[B_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_ROOK, WHITE, B_QUEEN, BLACK);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[B_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_ROOK, WHITE, B_ROOK, BLACK);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[B_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_ROOK, WHITE, B_BISHOP, BLACK);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[B_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_ROOK, WHITE, B_KNIGHT, BLACK);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[B_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_ROOK, WHITE, B_PAWN, BLACK);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}
	}
}

void genWhiteBishopMoves(MoveList* ml, Position* p) {
	int bishopLocs[10];
	int bishopCount = serialiseBoard(bishopLocs, p->pieceBB[W_BISHOP]);

	int i, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;

	for(i=0; i<bishopCount; i++) {
		from = bishopLocs[i];
		attackedSquares = 0;

		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_NW, from);
		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_NE, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_SE, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_SW, from);

		if(attackedSquares & p->pieceBB[BLACK]) {
			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[B_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_BISHOP, WHITE, B_QUEEN, BLACK);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[B_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_BISHOP, WHITE, B_ROOK, BLACK);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[B_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_BISHOP, WHITE, B_BISHOP, BLACK);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[B_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_BISHOP, WHITE, B_KNIGHT, BLACK);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[B_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_BISHOP, WHITE, B_PAWN, BLACK);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}

		quietMoves = attackedSquares & p->emptyBB;
		if(quietMoves) {
			prevBit = 0;
			do {
				to = bitScanForward(quietMoves);
				pushMoveList(ml, from, to+prevBit, FLAG_QUIET_MOVE, W_BISHOP, WHITE, 0, 0);
				prevBit += to;
				quietMoves >>= to;
			} while(quietMoves &= (quietMoves)-1);
		}

	}
}

void genWhiteBishopCaptures(MoveList* ml, Position* p) {
	int bishopLocs[10];
	int bishopCount = serialiseBoard(bishopLocs, p->pieceBB[W_BISHOP]);

	int i, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen;

	for(i=0; i<bishopCount; i++) {
		from = bishopLocs[i];
		attackedSquares = 0;

		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_NW, from);
		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_NE, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_SE, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_SW, from);

		if(attackedSquares & p->pieceBB[BLACK]) {
			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[B_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_BISHOP, WHITE, B_QUEEN, BLACK);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[B_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_BISHOP, WHITE, B_ROOK, BLACK);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[B_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_BISHOP, WHITE, B_BISHOP, BLACK);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[B_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_BISHOP, WHITE, B_KNIGHT, BLACK);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[B_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, W_BISHOP, WHITE, B_PAWN, BLACK);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}
	}
}

void genWhitePawnMoves(MoveList* ml, Position* p) {
	// Find indices of white pawns
	int pawnLocs[8];
	int pawnCount = serialiseBoard(pawnLocs, p->pieceBB[W_PAWN]);

	int i, rank, file, epGap, upLeft, upCentre, upRight, prevBit, from, to;
	uint64_t push, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;


	for(i=0; i<pawnCount; i++) {
		from = pawnLocs[i];
		rank = from / 8;
		file = from % 8;
		upLeft = from + 7;
		upCentre = from + 8;
		upRight = from + 9;

		switch(rank) {
			case 1:
				push = SQUARE_BBS[upCentre] & p->emptyBB;
				if(push) {
					pushMoveList(ml, from, upCentre, FLAG_PAWN_PUSH, W_PAWN, WHITE, 0, 0);
					if(SQUARE_BBS[from + 16] & p->emptyBB) {
						pushMoveList(ml, from, from + 16, FLAG_DOUBLE_PAWN_PUSH, W_PAWN, WHITE, 0, 0);
					}
				}

				switch(file) {
					case 0:
						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}

						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
						break;
				}
				break;
			case 2:
			case 3:
			case 4:
				epGap = p->flag.enPassantFlag - from;
				switch(file) {
					case 0:
						if(epGap == 1) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, W_PAWN, WHITE, B_PAWN, BLACK);
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						if((epGap == -1) || (epGap == 1)) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, W_PAWN, WHITE, B_PAWN, BLACK);
						}
						break;
					case 7:
						if(epGap == -1) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, W_PAWN, WHITE, B_PAWN, BLACK);
						}
						break;
				}

			case 5:
				push = SQUARE_BBS[upCentre] & p->emptyBB;
				if(push) {
					pushMoveList(ml, from, upCentre, FLAG_PAWN_PUSH, W_PAWN, WHITE, 0, 0);
				}

				switch(file) {
					case 0:
						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}

						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
				}
				break;
			case 6:
				push = SQUARE_BBS[upCentre] & p->emptyBB;
				if(push) {
					pushMoveList(ml, from, upCentre, FLAG_QUEEN_PROMO, W_PAWN, WHITE, 0, 0);
					pushMoveList(ml, from, upCentre, FLAG_ROOK_PROMO, W_PAWN, WHITE, 0, 0);
					pushMoveList(ml, from, upCentre, FLAG_BISHOP_PROMO, W_PAWN, WHITE, 0, 0);
					pushMoveList(ml, from, upCentre, FLAG_KNIGHT_PROMO, W_PAWN, WHITE, 0, 0);
				}

				switch(file) {
					case 0:
						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}
						}

						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}
						}
						break;
				}
		}
	}
}

void genWhitePawnCaptures(MoveList* ml, Position* p) {
	// Find indices of white pawns
	int pawnLocs[8];
	int pawnCount = serialiseBoard(pawnLocs, p->pieceBB[W_PAWN]);

	int i, rank, file, epGap, upLeft, upCentre, upRight, prevBit, from, to;
	uint64_t push, bPawn, bKnight, bBishop, bRook, bQueen;


	for(i=0; i<pawnCount; i++) {
		from = pawnLocs[i];
		rank = from / 8;
		file = from % 8;
		upLeft = from + 7;
		upCentre = from + 8;
		upRight = from + 9;

		switch(rank) {
			case 1:
				switch(file) {
					case 0:
						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}

						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
						break;
				}
				break;
			case 2:
			case 3:
			case 4:
				epGap = p->flag.enPassantFlag - from;
				switch(file) {
					case 0:
						if(epGap == 1) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, W_PAWN, WHITE, B_PAWN, BLACK);
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						if((epGap == -1) || (epGap == 1)) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, W_PAWN, WHITE, B_PAWN, BLACK);
						}
						break;
					case 7:
						if(epGap == -1) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, W_PAWN, WHITE, B_PAWN, BLACK);
						}
						break;
				}

			case 5:
				switch(file) {
					case 0:
						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}

						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upRight, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}

							bPawn = push & p->pieceBB[B_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, upLeft, FLAG_CAPTURES, W_PAWN, WHITE, B_PAWN, BLACK);
							}
						}
				}
				break;
			case 6:
			 	// Consider promotions with captures (also forcing)
				push = SQUARE_BBS[upCentre] & p->emptyBB;
				if(push) {
					pushMoveList(ml, from, upCentre, FLAG_QUEEN_PROMO, W_PAWN, WHITE, 0, 0);
					pushMoveList(ml, from, upCentre, FLAG_ROOK_PROMO, W_PAWN, WHITE, 0, 0);
					pushMoveList(ml, from, upCentre, FLAG_BISHOP_PROMO, W_PAWN, WHITE, 0, 0);
					pushMoveList(ml, from, upCentre, FLAG_KNIGHT_PROMO, W_PAWN, WHITE, 0, 0);
				}
				switch(file) {
					case 0:
						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							push = SQUARE_BBS[upRight];
							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}
						}
						push = SQUARE_BBS[upRight];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upRight, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upRight, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[upLeft];
						if(push & p->pieceBB[BLACK]) {
							bQueen = push & p->pieceBB[B_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_QUEEN, BLACK);
							}

							bRook = push & p->pieceBB[B_ROOK];
							if(bRook) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_ROOK, BLACK);
							}

							bBishop = push & p->pieceBB[B_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_BISHOP, BLACK);
							}

							bKnight = push & p->pieceBB[B_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, upLeft, FLAG_QUEEN_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_ROOK_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_BISHOP_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
								pushMoveList(ml, from, upLeft, FLAG_KNIGHT_PROMO_CAPT, W_PAWN, WHITE, B_KNIGHT, BLACK);
							}
						}
						break;
				}
		}
	}
}

// BLACK

void genBlackPawnMoves(MoveList* ml, Position* p) {
	// Find indices of white pawns
	int pawnLocs[8];
	int pawnCount = serialiseBoard(pawnLocs, p->pieceBB[B_PAWN]);

	int i, rank, file, epGap, downLeft, downCentre, downRight, prevBit, from, to;
	uint64_t push, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;

	for(i=0; i<pawnCount; i++) {
		from = pawnLocs[i];
		rank = from / 8;
		file = from % 8;
		downRight = from - 9;
		downCentre = from - 8;
		downLeft = from - 7;

		switch(rank) {
			case 6:
				push = SQUARE_BBS[downCentre] & p->emptyBB;
				if(push) {
					pushMoveList(ml, from, downCentre, FLAG_PAWN_PUSH, B_PAWN, BLACK, 0, 0);
					if(SQUARE_BBS[from - 16] & p->emptyBB) {
						pushMoveList(ml, from, from - 16, FLAG_DOUBLE_PAWN_PUSH, B_PAWN, BLACK, 0, 0);
					}
				}

				switch(file) {
					case 0:
						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}

						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
				}
				break;
			case 5:
			case 4:
			case 3:
				epGap = p->flag.enPassantFlag - from;
				switch(file) {
					case 0:
						if(epGap == 1) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, B_PAWN, BLACK, W_PAWN, WHITE);
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						if((epGap == -1) || (epGap == 1)) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, B_PAWN, BLACK, W_PAWN, WHITE);
						}
						break;
					case 7:
						if(epGap == -1) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, B_PAWN, BLACK, W_PAWN, WHITE);
						}
						break;
				}
			case 2:
				push = SQUARE_BBS[downCentre] & p->emptyBB;
				if(push) {
					pushMoveList(ml, from, downCentre, FLAG_PAWN_PUSH, B_PAWN, BLACK, 0, 0);
				}

				switch(file) {
					case 0:
						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}

						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
				}
				break;
			case 1:
				push = SQUARE_BBS[downCentre] & p->emptyBB;
				if(push) {
					pushMoveList(ml, from, downCentre, FLAG_QUEEN_PROMO, B_PAWN, BLACK, 0, 0);
					pushMoveList(ml, from, downCentre, FLAG_ROOK_PROMO, B_PAWN, BLACK, 0, 0);
					pushMoveList(ml, from, downCentre, FLAG_BISHOP_PROMO, B_PAWN, BLACK, 0, 0);
					pushMoveList(ml, from, downCentre, FLAG_KNIGHT_PROMO, B_PAWN, BLACK, 0, 0);
				}

				switch(file) {
					case 0:

						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							push = SQUARE_BBS[downLeft];
							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}
						}

						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}
						}
						break;
				}
		}
	}
}

void genBlackPawnCaptures(MoveList* ml, Position* p) {
	// Find indices of white pawns
	int pawnLocs[8];
	int pawnCount = serialiseBoard(pawnLocs, p->pieceBB[B_PAWN]);

	int i, rank, file, epGap, downLeft, downCentre, downRight, prevBit, from, to;
	uint64_t push, bPawn, bKnight, bBishop, bRook, bQueen;

	for(i=0; i<pawnCount; i++) {
		from = pawnLocs[i];
		rank = from / 8;
		file = from % 8;
		downRight = from - 9;
		downCentre = from - 8;
		downLeft = from - 7;

		switch(rank) {
			case 6:
				switch(file) {
					case 0:
						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}

						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
				}
				break;
			case 5:
			case 4:
			case 3:
				epGap = p->flag.enPassantFlag - from;
				switch(file) {
					case 0:
						if(epGap == 1) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, B_PAWN, BLACK, W_PAWN, WHITE);
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						if((epGap == -1) || (epGap == 1)) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, B_PAWN, BLACK, W_PAWN, WHITE);
						}
						break;
					case 7:
						if(epGap == -1) {
							pushMoveList(ml, from, p->flag.enPassantFlag+8, FLAG_EP_CAPTURE, B_PAWN, BLACK, W_PAWN, WHITE);
						}
						break;
				}
			case 2:
				switch(file) {
					case 0:
						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downLeft, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}

						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}

							bPawn = push & p->pieceBB[W_PAWN];
							if(bPawn) {
								pushMoveList(ml, from, downRight, FLAG_CAPTURES, B_PAWN, BLACK, W_PAWN, WHITE);
							}
						}
						break;
				}
				break;
			case 1:
				push = SQUARE_BBS[downCentre] & p->emptyBB;
				if(push) {
					pushMoveList(ml, from, downCentre, FLAG_QUEEN_PROMO, B_PAWN, BLACK, 0, 0);
					pushMoveList(ml, from, downCentre, FLAG_ROOK_PROMO, B_PAWN, BLACK, 0, 0);
					pushMoveList(ml, from, downCentre, FLAG_BISHOP_PROMO, B_PAWN, BLACK, 0, 0);
					pushMoveList(ml, from, downCentre, FLAG_KNIGHT_PROMO, B_PAWN, BLACK, 0, 0);
				}

				switch(file) {
					case 0:

						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							push = SQUARE_BBS[downLeft];
							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}
						}
						break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
						push = SQUARE_BBS[downLeft];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downLeft, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downLeft, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}
						}

						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}
						}
						break;
					case 7:
						push = SQUARE_BBS[downRight];
						if(push & p->pieceBB[WHITE]) {
							bQueen = push & p->pieceBB[W_QUEEN];
							if(bQueen) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_QUEEN, WHITE);
							}

							bRook = push & p->pieceBB[W_ROOK];
							if(bRook) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_ROOK, WHITE);
							}

							bBishop = push & p->pieceBB[W_BISHOP];
							if(bBishop) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_BISHOP, WHITE);
							}

							bKnight = push & p->pieceBB[W_KNIGHT];
							if(bKnight) {
								pushMoveList(ml, from, downRight, FLAG_QUEEN_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_ROOK_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_BISHOP_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
								pushMoveList(ml, from, downRight, FLAG_KNIGHT_PROMO_CAPT, B_PAWN, BLACK, W_KNIGHT, WHITE);
							}
						}
						break;
				}
		}
	}
}

void genBlackKnightMoves(MoveList* ml, Position* p) {

	// Find indices of black knights
	int knightLocs[10];
	int knightCount = serialiseBoard(knightLocs, p->pieceBB[B_KNIGHT]);

	int i, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;

	for(i=0; i<knightCount; i++) {
		from = knightLocs[i];
		attackedSquares = KNIGHT_ATTACKS[from];

		if(attackedSquares & p->pieceBB[WHITE]) {
			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[W_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KNIGHT, BLACK, W_QUEEN, WHITE);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[W_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KNIGHT, BLACK, W_ROOK, WHITE);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[W_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KNIGHT, BLACK, W_BISHOP, WHITE);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[W_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KNIGHT, BLACK, W_KNIGHT, WHITE);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[W_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KNIGHT, BLACK, W_PAWN, WHITE);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}

		quietMoves = attackedSquares & p->emptyBB;
		if(quietMoves) {
			prevBit = 0;
			do {
				to = bitScanForward(quietMoves);
				pushMoveList(ml, from, to+prevBit, FLAG_QUIET_MOVE, B_KNIGHT, BLACK, 0, 0);
				prevBit += to;
				quietMoves >>= to;
			} while(quietMoves &= (quietMoves)-1);
		}
	}
}

void genBlackKnightCaptures(MoveList* ml, Position* p) {

	// Find indices of black knights
	int knightLocs[10];
	int knightCount = serialiseBoard(knightLocs, p->pieceBB[B_KNIGHT]);

	int i, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen;

	for(i=0; i<knightCount; i++) {
		from = knightLocs[i];
		attackedSquares = KNIGHT_ATTACKS[from];

		if(attackedSquares & p->pieceBB[WHITE]) {
			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[W_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KNIGHT, BLACK, W_QUEEN, WHITE);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[W_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KNIGHT, BLACK, W_ROOK, WHITE);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[W_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KNIGHT, BLACK, W_BISHOP, WHITE);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[W_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KNIGHT, BLACK, W_KNIGHT, WHITE);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[W_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KNIGHT, BLACK, W_PAWN, WHITE);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}
	}
}

void genBlackKingMoves(MoveList* ml, Position* p) {
	int from = LOG2(p->pieceBB[B_KING]);
	// serialiseBoard(&from, p->pieceBB[B_KING], B_KING);

	int i, prevBit, to;
	uint64_t attackedSquares, dangerSquares, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;

	attackedSquares = KING_ATTACKS[from];
	// Bitboard of neighbouring squares attacked by black pieces
	dangerSquares = prevBit = 0;
	// Temporarily vanish king so it doesn't interfere
	p->occupiedBB	^= p->pieceBB[B_KING];
	p->emptyBB		^= p->pieceBB[B_KING];
	do {
		to = bitScanForward(attackedSquares);
		// outputBitBoard(SQUARE_BBS[to+prevBit]);
		dangerSquares |= attackedByWhiteBitBoard(p, SQUARE_BBS[to+prevBit]);
		prevBit += to;
		attackedSquares >>= to;
	} while(attackedSquares &= (attackedSquares)-1);
	p->occupiedBB ^= p->pieceBB[B_KING];
	p->emptyBB		^= p->pieceBB[B_KING];

	attackedSquares = KING_ATTACKS[from] &~ dangerSquares;

	if(attackedSquares & p->pieceBB[WHITE]) {
		// Do we attack any white queens?
		bQueen = attackedSquares & p->pieceBB[W_QUEEN];
		if(bQueen) {
			prevBit = 0;
			do {
				to = bitScanForward(bQueen);
				if(!attackedByWhite(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KING, BLACK, W_QUEEN, WHITE);
				}
				prevBit += to;
				bQueen >>= to;
			} while(bQueen &= (bQueen)-1);
		}

		bRook = attackedSquares & p->pieceBB[W_ROOK];
		if(bRook) {
			prevBit = 0;
			do {
				to = bitScanForward(bRook);
				if(!attackedByWhite(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KING, BLACK, W_ROOK, WHITE);
				}
				prevBit += to;
				bRook >>= to;
			} while(bRook &= (bRook)-1);
		}

		bBishop = attackedSquares & p->pieceBB[W_BISHOP];
		if(bBishop) {
			prevBit = 0;
			do {
				to = bitScanForward(bBishop);
				if(!attackedByWhite(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KING, BLACK, W_BISHOP, WHITE);
				}
				prevBit += to;
				bBishop >>= to;
			} while(bBishop &= (bBishop)-1);
		}

		bKnight = attackedSquares & p->pieceBB[W_KNIGHT];
		if(bKnight) {
			prevBit = 0;
			do {
				to = bitScanForward(bKnight);
				if(!attackedByWhite(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KING, BLACK, W_KNIGHT, WHITE);
				}
				prevBit += to;
				bKnight >>= to;
			} while(bKnight &= (bKnight)-1);
		}

		bPawn = attackedSquares & p->pieceBB[W_PAWN];
		if(bPawn) {
			prevBit = 0;
			do {
				to = bitScanForward(bPawn);
				if(!attackedByWhite(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KING, BLACK, W_PAWN, WHITE);
				}
				prevBit += to;
				bPawn >>= to;
			} while(bPawn &= (bPawn)-1);
		}
	}

	quietMoves = attackedSquares & p->emptyBB;
	if(quietMoves) {
		prevBit = 0;
		do {
			to = bitScanForward(quietMoves);
			if(!attackedByWhite(p, SQUARE_BBS[to+prevBit])) {
				pushMoveList(ml, from, to+prevBit, FLAG_QUIET_MOVE, B_KING, BLACK, 0, 0);
			}
			prevBit += to;
			quietMoves >>= to;
		} while(quietMoves &= (quietMoves)-1);
	}

	if((p->flag.castlingFlags & B_KSIDE_CASTLE) && (p->emptyBB & F8) && (p->emptyBB & G8) && !(attackedByWhite(p, SQUARE_BBS[E8_INT])) && !(attackedByWhite(p, SQUARE_BBS[F8_INT])) && !(attackedByWhite(p, SQUARE_BBS[G8_INT]))) {
		pushMoveList(ml, E8_INT, G8_INT, FLAG_KING_CASTLE, B_KING, BLACK, 0, 0);
	}
	if((p->flag.castlingFlags & B_QSIDE_CASTLE) && (p->emptyBB & D8) && (p->emptyBB & C8) && (p->emptyBB & B8) && !(attackedByWhite(p, SQUARE_BBS[E8_INT])) && !(attackedByWhite(p, SQUARE_BBS[D8_INT])) && !(attackedByWhite(p, SQUARE_BBS[C8_INT]))) {
		pushMoveList(ml, E8_INT, C8_INT, FLAG_QUEEN_CASTLE, B_KING, BLACK, 0, 0);
	}
}

void genBlackKingCaptures(MoveList* ml, Position* p) {
	int from = LOG2(p->pieceBB[B_KING]);
	// serialiseBoard(&from, p->pieceBB[B_KING], B_KING);

	int i, prevBit, to;
	uint64_t attackedSquares, dangerSquares, bPawn, bKnight, bBishop, bRook, bQueen;

	attackedSquares = KING_ATTACKS[from];
	// Bitboard of neighbouring squares attacked by black pieces
	dangerSquares = prevBit = 0;
	// Temporarily vanish king so it doesn't interfere
	p->occupiedBB	^= p->pieceBB[B_KING];
	p->emptyBB		^= p->pieceBB[B_KING];
	do {
		to = bitScanForward(attackedSquares);
		// outputBitBoard(SQUARE_BBS[to+prevBit]);
		dangerSquares |= attackedByWhiteBitBoard(p, SQUARE_BBS[to+prevBit]);
		prevBit += to;
		attackedSquares >>= to;
	} while(attackedSquares &= (attackedSquares)-1);
	p->occupiedBB ^= p->pieceBB[B_KING];
	p->emptyBB		^= p->pieceBB[B_KING];

	attackedSquares = KING_ATTACKS[from] &~ dangerSquares;

	if(attackedSquares & p->pieceBB[WHITE]) {
		// Do we attack any white queens?
		bQueen = attackedSquares & p->pieceBB[W_QUEEN];
		if(bQueen) {
			prevBit = 0;
			do {
				to = bitScanForward(bQueen);
				if(!attackedByWhite(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KING, BLACK, W_QUEEN, WHITE);
				}
				prevBit += to;
				bQueen >>= to;
			} while(bQueen &= (bQueen)-1);
		}

		bRook = attackedSquares & p->pieceBB[W_ROOK];
		if(bRook) {
			prevBit = 0;
			do {
				to = bitScanForward(bRook);
				if(!attackedByWhite(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KING, BLACK, W_ROOK, WHITE);
				}
				prevBit += to;
				bRook >>= to;
			} while(bRook &= (bRook)-1);
		}

		bBishop = attackedSquares & p->pieceBB[W_BISHOP];
		if(bBishop) {
			prevBit = 0;
			do {
				to = bitScanForward(bBishop);
				if(!attackedByWhite(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KING, BLACK, W_BISHOP, WHITE);
				}
				prevBit += to;
				bBishop >>= to;
			} while(bBishop &= (bBishop)-1);
		}

		bKnight = attackedSquares & p->pieceBB[W_KNIGHT];
		if(bKnight) {
			prevBit = 0;
			do {
				to = bitScanForward(bKnight);
				if(!attackedByWhite(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KING, BLACK, W_KNIGHT, WHITE);
				}
				prevBit += to;
				bKnight >>= to;
			} while(bKnight &= (bKnight)-1);
		}

		bPawn = attackedSquares & p->pieceBB[W_PAWN];
		if(bPawn) {
			prevBit = 0;
			do {
				to = bitScanForward(bPawn);
				if(!attackedByWhite(p, SQUARE_BBS[to+prevBit])) {
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_KING, BLACK, W_PAWN, WHITE);
				}
				prevBit += to;
				bPawn >>= to;
			} while(bPawn &= (bPawn)-1);
		}
	}
}

void genBlackQueenMoves(MoveList* ml, Position* p) {
	int queenLocs[9];
	int queenCount = serialiseBoard(queenLocs, p->pieceBB[B_QUEEN]);

	int i, dir, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;

	for(i=0; i<queenCount; i++) {
		from = queenLocs[i];
		attackedSquares = 0;

		for(dir=DIR_N; dir<= DIR_NE; dir++) {
			attackedSquares |= positiveRayAttacks(p->occupiedBB, dir, from);
		}
		for(dir=DIR_S; dir<= DIR_SW; dir++) {
			attackedSquares |= negativeRayAttacks(p->occupiedBB, dir, from);
		}

		if(attackedSquares & p->pieceBB[WHITE]) {
			// Do we attack any white queens?
			bQueen = attackedSquares & p->pieceBB[W_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_QUEEN, BLACK, W_QUEEN, WHITE);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[W_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_QUEEN, BLACK, W_ROOK, WHITE);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[W_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_QUEEN, BLACK, W_BISHOP, WHITE);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[W_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_QUEEN, BLACK, W_KNIGHT, WHITE);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[W_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_QUEEN, BLACK, W_PAWN, WHITE);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}

		quietMoves = attackedSquares & p->emptyBB;
		if(quietMoves) {
			prevBit = 0;
			do {
				to = bitScanForward(quietMoves);
				pushMoveList(ml, from, to+prevBit, FLAG_QUIET_MOVE, B_QUEEN, BLACK, 0, 0);
				prevBit += to;
				quietMoves >>= to;
			} while(quietMoves &= (quietMoves)-1);
		}
	}
}

void genBlackQueenCaptures(MoveList* ml, Position* p) {
	int queenLocs[9];
	int queenCount = serialiseBoard(queenLocs, p->pieceBB[B_QUEEN]);

	int i, dir, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen;

	for(i=0; i<queenCount; i++) {
		from = queenLocs[i];
		attackedSquares = 0;

		for(dir=DIR_N; dir<= DIR_NE; dir++) {
			attackedSquares |= positiveRayAttacks(p->occupiedBB, dir, from);
		}
		for(dir=DIR_S; dir<= DIR_SW; dir++) {
			attackedSquares |= negativeRayAttacks(p->occupiedBB, dir, from);
		}

		if(attackedSquares & p->pieceBB[WHITE]) {
			// Do we attack any white queens?
			bQueen = attackedSquares & p->pieceBB[W_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_QUEEN, BLACK, W_QUEEN, WHITE);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[W_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_QUEEN, BLACK, W_ROOK, WHITE);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[W_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_QUEEN, BLACK, W_BISHOP, WHITE);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[W_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_QUEEN, BLACK, W_KNIGHT, WHITE);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[W_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_QUEEN, BLACK, W_PAWN, WHITE);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}
	}
}

void genBlackRookMoves(MoveList* ml, Position* p) {

	int rookLocs[10];
	int rookCount = serialiseBoard(rookLocs, p->pieceBB[B_ROOK]);

	int i, dir, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;

	for(i=0; i<rookCount; i++) {
		from = rookLocs[i];
		attackedSquares = 0;

		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_N, from);
		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_E, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_S, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_W, from);

		if(attackedSquares & p->pieceBB[WHITE]) {
			bQueen = attackedSquares & p->pieceBB[W_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_ROOK, BLACK, W_QUEEN, WHITE);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[W_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_ROOK, BLACK, W_ROOK, WHITE);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[W_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_ROOK, BLACK, W_BISHOP, WHITE);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[W_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_ROOK, BLACK, W_KNIGHT, WHITE);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[W_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_ROOK, BLACK, W_PAWN, WHITE);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}

		quietMoves = attackedSquares & p->emptyBB;
		if(quietMoves) {
			prevBit = 0;
			do {
				to = bitScanForward(quietMoves);
				pushMoveList(ml, from, to+prevBit, FLAG_QUIET_MOVE, B_ROOK, BLACK, 0, 0);
				prevBit += to;
				quietMoves >>= to;
			} while(quietMoves &= (quietMoves)-1);
		}
	}
}

void genBlackRookCaptures(MoveList* ml, Position* p) {

	int rookLocs[10];
	int rookCount = serialiseBoard(rookLocs, p->pieceBB[B_ROOK]);

	int i, dir, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen;

	for(i=0; i<rookCount; i++) {
		from = rookLocs[i];
		attackedSquares = 0;

		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_N, from);
		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_E, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_S, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_W, from);

		if(attackedSquares & p->pieceBB[WHITE]) {
			bQueen = attackedSquares & p->pieceBB[W_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_ROOK, BLACK, W_QUEEN, WHITE);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[W_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_ROOK, BLACK, W_ROOK, WHITE);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[W_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_ROOK, BLACK, W_BISHOP, WHITE);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[W_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_ROOK, BLACK, W_KNIGHT, WHITE);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[W_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_ROOK, BLACK, W_PAWN, WHITE);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}
	}
}

void genBlackBishopMoves(MoveList* ml, Position* p) {
	int bishopLocs[10];
	int bishopCount = serialiseBoard(bishopLocs, p->pieceBB[B_BISHOP]);

	int i, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen, quietMoves;

	for(i=0; i<bishopCount; i++) {
		from = bishopLocs[i];
		attackedSquares = 0;

		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_NW, from);
		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_NE, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_SE, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_SW, from);

		if(attackedSquares & p->pieceBB[WHITE]) {
			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[W_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_BISHOP, BLACK, W_QUEEN, WHITE);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[W_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_BISHOP, BLACK, W_ROOK, WHITE);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[W_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_BISHOP, BLACK, W_BISHOP, WHITE);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[W_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_BISHOP, BLACK, W_KNIGHT, WHITE);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[W_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_BISHOP, BLACK, W_PAWN, WHITE);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}

		quietMoves = attackedSquares & p->emptyBB;
		if(quietMoves) {
			prevBit = 0;
			do {
				to = bitScanForward(quietMoves);
				pushMoveList(ml, from, to+prevBit, FLAG_QUIET_MOVE, B_BISHOP, BLACK, 0, 0);
				prevBit += to;
				quietMoves >>= to;
			} while(quietMoves &= (quietMoves)-1);
		}
	}
}

void genBlackBishopCaptures(MoveList* ml, Position* p) {
	int bishopLocs[10];
	int bishopCount = serialiseBoard(bishopLocs, p->pieceBB[B_BISHOP]);

	int i, prevBit, from, to;
	uint64_t attackedSquares, bPawn, bKnight, bBishop, bRook, bQueen;

	for(i=0; i<bishopCount; i++) {
		from = bishopLocs[i];
		attackedSquares = 0;

		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_NW, from);
		attackedSquares |= positiveRayAttacks(p->occupiedBB, DIR_NE, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_SE, from);
		attackedSquares |= negativeRayAttacks(p->occupiedBB, DIR_SW, from);

		if(attackedSquares & p->pieceBB[WHITE]) {
			// Do we attack any black queens?
			bQueen = attackedSquares & p->pieceBB[W_QUEEN];
			if(bQueen) {
				prevBit = 0;
				do {
					to = bitScanForward(bQueen);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_BISHOP, BLACK, W_QUEEN, WHITE);
					prevBit += to;
					bQueen >>= to;
				} while(bQueen &= (bQueen)-1);
			}

			bRook = attackedSquares & p->pieceBB[W_ROOK];
			if(bRook) {
				prevBit = 0;
				do {
					to = bitScanForward(bRook);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_BISHOP, BLACK, W_ROOK, WHITE);
					prevBit += to;
					bRook >>= to;
				} while(bRook &= (bRook)-1);
			}

			bBishop = attackedSquares & p->pieceBB[W_BISHOP];
			if(bBishop) {
				prevBit = 0;
				do {
					to = bitScanForward(bBishop);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_BISHOP, BLACK, W_BISHOP, WHITE);
					prevBit += to;
					bBishop >>= to;
				} while(bBishop &= (bBishop)-1);
			}

			bKnight = attackedSquares & p->pieceBB[W_KNIGHT];
			if(bKnight) {
				prevBit = 0;
				do {
					to = bitScanForward(bKnight);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_BISHOP, BLACK, W_KNIGHT, WHITE);
					prevBit += to;
					bKnight >>= to;
				} while(bKnight &= (bKnight)-1);
			}

			bPawn = attackedSquares & p->pieceBB[W_PAWN];
			if(bPawn) {
				prevBit = 0;
				do {
					to = bitScanForward(bPawn);
					pushMoveList(ml, from, to+prevBit, FLAG_CAPTURES, B_BISHOP, BLACK, W_PAWN, WHITE);
					prevBit += to;
					bPawn >>= to;
				} while(bPawn &= (bPawn)-1);
			}
		}
	}
}

void genWhiteCaptures(MoveList* ml, Position* p) {
	genWhitePawnCaptures(ml, p);
	genWhiteKnightCaptures(ml, p);
	genWhiteBishopCaptures(ml, p);
	genWhiteRookCaptures(ml, p);
	genWhiteQueenCaptures(ml, p);
	genWhiteKingCaptures(ml, p);
}

void genBlackCaptures(MoveList* ml, Position* p) {
	genBlackPawnCaptures(ml, p);
	genBlackKnightCaptures(ml, p);
	genBlackBishopCaptures(ml, p);
	genBlackRookCaptures(ml, p);
	genBlackQueenCaptures(ml, p);
	genBlackKingCaptures(ml, p);
}


void genWhiteMoves(MoveList* ml, Position* p) {

	genWhitePawnMoves(ml, p);
	genWhiteBishopMoves(ml, p);
	genWhiteRookMoves(ml, p);
	genWhiteKnightMoves(ml, p);
	genWhiteQueenMoves(ml, p);
	genWhiteKingMoves(ml, p);

}

void genBlackMoves(MoveList* ml, Position* p) {

	genBlackPawnMoves(ml, p);
	genBlackBishopMoves(ml, p);
	genBlackRookMoves(ml, p);
	genBlackKnightMoves(ml, p);
	genBlackQueenMoves(ml, p);
	genBlackKingMoves(ml, p);
}

void genMoves(MoveList* ml, Position* p) {
	// ml->used = 0;
	initMoveList(ml, 30);
	if(p->player == WHITE) {
		genWhiteMoves(ml, p);
	} else {
		genBlackMoves(ml, p);
	}
}

uint64_t attackedByBlackBitBoard(Position* p, uint64_t bb) {
	// int square = bitScanReverse(bb);
	int square = LOG2(bb);

 	uint64_t attacks = whitePawnAttacks(square);
	uint64_t validAttacks = attacks & p->pieceBB[B_PAWN];
	attacks = KNIGHT_ATTACKS[square];
	validAttacks |= (attacks & p->pieceBB[B_KNIGHT]);
	attacks = bishopAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[B_BISHOP]);
	attacks = rookAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[B_ROOK]);
	attacks = queenAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[B_QUEEN]);
	attacks = KING_ATTACKS[square];
	validAttacks |= (attacks & p->pieceBB[B_KING]);
	return (validAttacks > 0) ? bb : 0;
}

int attackedByBlack(Position* p, uint64_t bb) {
	// int square = bitScanReverse(bb);
	int square = LOG2(bb);

 	uint64_t attacks = whitePawnAttacks(square);
	uint64_t validAttacks = attacks & p->pieceBB[B_PAWN];
	attacks = KNIGHT_ATTACKS[square];
	validAttacks |= (attacks & p->pieceBB[B_KNIGHT]);
	attacks = bishopAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[B_BISHOP]);
	attacks = rookAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[B_ROOK]);
	attacks = queenAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[B_QUEEN]);
	attacks = KING_ATTACKS[square];
	validAttacks |= (attacks & p->pieceBB[B_KING]);
	return (validAttacks > 0);
}

uint64_t attackedByWhiteBitBoard(Position* p, uint64_t bb) {
	// int square = bitScanReverse(bb);
	int square = LOG2(bb);

 	uint64_t attacks = blackPawnAttacks(square);
	uint64_t validAttacks = attacks & p->pieceBB[W_PAWN];
	attacks = KNIGHT_ATTACKS[square];
	validAttacks |= (attacks & p->pieceBB[W_KNIGHT]);
	attacks = bishopAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[W_BISHOP]);
	attacks = rookAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[W_ROOK]);
	attacks = queenAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[W_QUEEN]);
	attacks = KING_ATTACKS[square];
	validAttacks |= (attacks & p->pieceBB[W_KING]);
	return (validAttacks > 0) ? bb : 0;
}

int attackedByWhite(Position* p, uint64_t bb) {
	// int square = bitScanReverse(bb);
	int square = LOG2(bb);

 	uint64_t attacks = blackPawnAttacks(square);
	uint64_t validAttacks = attacks & p->pieceBB[W_PAWN];
	attacks = KNIGHT_ATTACKS[square];
	validAttacks |= (attacks & p->pieceBB[W_KNIGHT]);
	attacks = bishopAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[W_BISHOP]);
	attacks = rookAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[W_ROOK]);
	attacks = queenAttacks(p, square);
	validAttacks |= (attacks & p->pieceBB[W_QUEEN]);
	attacks = KING_ATTACKS[square];
	validAttacks |= (attacks & p->pieceBB[W_KING]);
	return (validAttacks > 0);
}

void removalIllegalWhiteMoves(MoveList* ml, Position* p, IrrFlagStack* fs) {

	int keepFlags[ml->used];
	int i, j;
	for(i=0; i<ml->used; i++) {
		keepFlags[i] = TRUE;
		if(ml->list[i].piece == W_KING) {
			continue;
		}
		makeMove(p, &ml->list[i], fs);
		if(attackedByBlack(p, p->pieceBB[W_KING])) {
			keepFlags[i] = FALSE;
		}
		unmakeMove(p, &ml->list[i], fs);
	}
	j=0;
	for(i=0; i<ml->used; i++) {
		if(keepFlags[i]) {
			ml->list[j++] = ml->list[i];
		}
	}
	ml->used = j;

}

void removalIllegalBlackMoves(MoveList* ml, Position* p, IrrFlagStack* fs) {
	// int removalCount;
	int keepFlags[ml->used];
	int i, j;
	for(i=0; i<ml->used; i++) {
		keepFlags[i] = TRUE;
		if(ml->list[i].piece == W_KING) {
			continue;
		}
		makeMove(p, &ml->list[i], fs);

		if(attackedByWhite(p, p->pieceBB[B_KING])) {
			keepFlags[i] = FALSE;

		}
		unmakeMove(p, &ml->list[i], fs);
	}
	j=0;
	for(i=0; i<ml->used; i++) {
		if(keepFlags[i]) {
			ml->list[j++] = ml->list[i];
		}
	}
	ml->used = j;
}

void genLegalMoves(MoveList* ml, Position* p, IrrFlagStack* fs) {
	genMoves(ml, p);
	if(p->player == WHITE) {
		removalIllegalWhiteMoves(ml, p, fs);
	} else {
		removalIllegalBlackMoves(ml, p, fs);
	}
}

void genCaptures(MoveList* ml, Position* p, IrrFlagStack* fs) {
	initMoveList(ml, 8);
	if(p->player == WHITE) {
		genWhiteCaptures(ml, p);
		removalIllegalWhiteMoves(ml, p, fs);
	} else {
		genBlackCaptures(ml, p);
		removalIllegalBlackMoves(ml, p, fs);
	}
}

// Move createMoveFromAlgebraic(char* s, Position* b, IrrFlagStack* fs) {
// 	int from = algebraicToIndex(s);
// 	int to = algebraicToIndex(&s[2]);
// 	if(s[4] != 0) {
// 		int promotionPiece = charToPiece(s[4]);
// 		return createSpecialMove(from, to, 0, 0, promotionPiece, b);
// 	}
// 	return createMove(from, to, b);
// }

int scoreFinalPosition(Position* p) {
	int res = attackedByWhite(p, p->pieceBB[B_KING]);
	res += attackedByBlack(p, p->pieceBB[W_KING]) << 1;
	return res;
}

int finalResult(Position* p) {
	int res = scoreFinalPosition(p);
	switch(res) {
		case 0:
			return RES_STALEMATE;
		case 1:
			return RES_WHITE_WIN;
		case 2:
			return RES_BLACK_WIN;
		default:
			return RES_UNFINISHED;
	}
}

// Number of squares attacked by white pieces
// Extra weight for attacking (squares around) black king
int whiteMobility(Position* p) {
	int i, square, total;
	uint64_t attackBB;

	uint64_t bKing = p->pieceBB[B_KING];
	int bkPos = LOG2(bKing);
	uint64_t surround = KING_ATTACKS[bkPos] | bKing;

	int whiteLocs[32];
	int whiteCount = serialiseBoard(whiteLocs, p->pieceBB[WHITE]);

	for(i=0; i<whiteCount; i++) {
		square = whiteLocs[i];
		attackBB = p->squareAttacksBB[square];
		total += popCount(attackBB) + (popCount(attackBB &  surround)*SAFETY_FACTOR);
	}
	return total;
}

// Number of squares attacked by black pieces
// Extra weight for attacking (squares around) black king
int blackMobility(Position* p) {
	int i, square, total;
	uint64_t attackBB;

	uint64_t wKing = p->pieceBB[W_KING];
	int wkPos = LOG2(wKing);
	uint64_t surround = KING_ATTACKS[wkPos] | wKing;

	int blackLocs[32];
	int blackCount = serialiseBoard(blackLocs, p->pieceBB[BLACK]);

	for(i=0; i<blackCount; i++) {
		square = blackLocs[i];
		attackBB = p->squareAttacksBB[square];
		total += popCount(attackBB) + (popCount(attackBB &  surround)*SAFETY_FACTOR);
	}
	return total;
}

// int whiteKingSafety(Position* p) {
// 	int score = 0;
// 	int kPos = LOG2(p->pieceBB[W_KING]);
// 	uint64_t surround = KING_ATTACKS[kPos];
// 	uint64_t shield = surround |= p->pieceBB[W_PAWN];
// 	score =
// }

int heuristicEval(Position* p) {
	// int i, score;
	// score = 0;
	// for(i=W_PAWN; i<=B_KING; i++) {
	// 	score += popCount(p->pieceBB[i]) * PIECE_VALUES[i];
	// }
	int score = p->materialCount + p->squareValueTotal;
	score += (whiteMobility(p) - blackMobility(p)) * MOBILITY_FACTOR;
	// score += (whiteKingSafety(p) - blackKingSafety(p)) * SAFETY_FACTOR;
	score *= (1 - p->flag.plyCount/50);
	return score;
}

int dirtyAlphaBeta(Position* p, IrrFlagStack* fs, int depth, int maxExtensions, int alpha, int beta) {
	// printf("Minimax, Depth=%d, alpha=%d, beta=%d\n", depth, alpha, beta);
	// outputBoard(b);
	if(depth == 0) {
		return heuristicEval(p);
	}

	MoveList ml;
	genMoves(&ml, p);
	int numMoves = ml.used;
	if(numMoves == 0) {
		freeMoveList(&ml);
		return heuristicEval(p);
	}
	int bestScore, eval;
	Move m;
	// int bestIndex = 0;
	if(p->player == WHITE) {
		// Maximising player
		bestScore = INT_MIN;
		for(int i=0; i<numMoves; i++) {
			m = ml.list[i];
			if(m.cPiece == B_KING) {
				return 10000;
			}
			makeMove(p, &m, fs);
			eval = dirtyAlphaBeta(p, fs, depth - 1, maxExtensions, alpha, beta);
			unmakeMove(p, &m, fs);
			bestScore = (bestScore > eval) ? bestScore : eval;
			alpha = (alpha > bestScore) ? alpha : bestScore;
			if(alpha >= beta) {
				break;
			}
		}
	} else {
		// Minimising player
		bestScore = INT_MAX;
		for(int i=0; i<numMoves; i++) {
			m = ml.list[i];
			if(m.cPiece == W_KING) {
				return -10000;
			}
			makeMove(p, &m, fs);
			eval = dirtyAlphaBeta(p, fs, depth - 1, maxExtensions, alpha, beta);
			unmakeMove(p, &m, fs);
			bestScore = (bestScore < eval) ? bestScore : eval;
			beta = (beta < bestScore) ? beta : bestScore;
			if(beta <= alpha) {
				break;
			}
		}
	}
	// printf("Returning: %d", bestScore);
	freeMoveList(&ml);

	return bestScore;
}

//	quickSort
//  @author Darel Rex Finley
void qsortMoveList(MoveList* ml, int* vals, int elements) {

  int piv, L, R;
	int beg[128], end[128];
	int i=0;
	Move tempMove;

  beg[0]=0;
	end[0]=elements;
  while (i>=0) {
    L=beg[i];
		R=end[i]-1;
    if (L<R) {
      piv=vals[L];
			tempMove =ml->list[L];
			if (i==127) return;
      while (L<R) {
        while (vals[R]>=piv && L<R)
					R--;
				if (L<R) {
					ml->list[L]=ml->list[R];
					vals[L++]=vals[R];
				}
        while (vals[L]<=piv && L<R)
					L++;
				if (L<R) {
					ml->list[R]=ml->list[L];
					vals[R--]=vals[L];
				}
			}
			ml->list[L]=tempMove;
      vals[L]=piv;
			beg[i+1]=L+1;
			end[i+1]=end[i];
			end[i++]=L;
		}
    else {
      i--;
		}
	}
}


// Most value victim + least valuable attacker
void sortCapturesMVVLVA(MoveList* ml) {
	int length = ml->used;
	int values[length];
	int i;
	for(i=0; i<length; i++) {
		values[i] = PIECE_VALUES_ABS[ml->list[i].piece] - PIECE_VALUES_ABS[ml->list[i].cPiece];
	}
	qsortMoveList(ml, values, length);
}

// Most value victim
void sortCapturesMVV(MoveList* ml) {
	int length = ml->used;
	int values[length];
	int i;
	for(i=0; i<length; i++) {
		values[i] = -PIECE_VALUES_ABS[ml->list[i].cPiece];
	}
	qsortMoveList(ml, values, length);
}

int quiescenceSearch(Position* p, IrrFlagStack* fs, int maxExtensions, int alpha, int beta) {
	// printf("quiescenceSearch, Depth=%d, alpha=%d, beta=%d\n", maxExtensions, alpha, beta);
	// TODO
	if(maxExtensions == 0) {
		return heuristicEval(p);
	}

	int standPat = heuristicEval(p);
	if(standPat >= beta) {
		return standPat;
	}
	if(alpha < standPat) {
		alpha = standPat;
	}

	MoveList ml;
	genCaptures(&ml, p, fs);
	// outputPosition(p);
	// outputMoveList(&ml, '\n', TRUE);
	sortCapturesMVVLVA(&ml);
	// outputMoveList(&ml, '\n', TRUE);
	int numMoves = ml.used;
	if(numMoves == 0) {
		freeMoveList(&ml);
		// return heuristicEval(p);
		return standPat;
	}
	int bestScore, eval;
	Move* m;
	// int bestIndex = 0;
	if(p->player == WHITE) {
		// Maximising player
		bestScore = INT_MIN;
		for(int i=0; i<numMoves; i++) {
			m = &ml.list[i];
			makeMove(p, m, fs);
			eval = quiescenceSearch(p, fs, maxExtensions - 1, alpha, beta);
			unmakeMove(p, m, fs);
			bestScore = (bestScore > eval) ? bestScore : eval;
			alpha = (alpha > bestScore) ? alpha : bestScore;
			if(alpha >= beta) {
				break;
			}
		}
	} else {
		// Minimising player
		bestScore = INT_MAX;
		for(int i=0; i<numMoves; i++) {
			m =  &ml.list[i];
			makeMove(p, m, fs);
			eval = quiescenceSearch(p, fs, maxExtensions - 1, alpha, beta);
			unmakeMove(p, m, fs);
			bestScore = (bestScore < eval) ? bestScore : eval;
			beta = (beta < bestScore) ? beta : bestScore;
			if(beta <= alpha) {
				break;
			}
		}
	}
	// printf("Returning: %d", bestScore);
	freeMoveList(&ml);

	return bestScore;
}

int alphaBeta(Position* p, IrrFlagStack* fs, int depth, int maxExtensions, int alpha, int beta, int capture) {
	// printf("Minimax, Depth=%d, alpha=%d, beta=%d\n", depth, alpha, beta);
	// outputBoard(b);
	if(depth == 0) {
		switch(capture) {
			case 0:
				return heuristicEval(p);
			default:
				return quiescenceSearch(p, fs, maxExtensions, alpha, beta);
		}
	}

	MoveList ml;
	genLegalMoves(&ml, p, fs);
	sortCapturesMVV(&ml);
	int numMoves = ml.used;
	if(numMoves == 0) {
		freeMoveList(&ml);
		switch(scoreFinalPosition(p)) {
			case RES_WHITE_WIN:
				return 10000;
			case RES_BLACK_WIN:
				return -10000;
			default:
				return 0;
		}
	}
	int bestScore, eval;
	Move* m;
	// int bestIndex = 0;
	if(p->player == WHITE) {
		// Maximising player
		bestScore = INT_MIN;
		for(int i=0; i<numMoves; i++) {
			m = &ml.list[i];
			makeMove(p, m, fs);
			eval = alphaBeta(p, fs, depth - 1, maxExtensions, alpha, beta, m->cPiece);
			unmakeMove(p, m, fs);
			bestScore = (bestScore > eval) ? bestScore : eval;
			alpha = (alpha > bestScore) ? alpha : bestScore;
			if(alpha >= beta) {
				break;
			}
		}
	} else {
		// Minimising player
		bestScore = INT_MAX;
		for(int i=0; i<numMoves; i++) {
			m =  &ml.list[i];
			makeMove(p, m, fs);
			eval = alphaBeta(p, fs, depth - 1, maxExtensions, alpha, beta, m->cPiece);
			unmakeMove(p, m, fs);
			bestScore = (bestScore < eval) ? bestScore : eval;
			beta = (beta < bestScore) ? beta : bestScore;
			if(beta <= alpha) {
				break;
			}
		}
	}
	// printf("Returning: %d", bestScore);
	freeMoveList(&ml);

	return bestScore;
}
//
//
Move ai(Position* p, IrrFlagStack* fs, int depth, int aiMode, int maxExtensions, int verbose) {
	MoveList ml;
	Move returnMove;
	genLegalMoves(&ml, p, fs);
	int numMoves = ml.used;
	if(numMoves == 0) {
		printf("Error: No legal moves.\n");
		freeMoveList(&ml);
		return returnMove;
	}
	int scores[numMoves];
	int bestScore, alpha, beta;
	int bestIndex = 0;
	Move *m;
	alpha = INT_MIN;
	beta = INT_MAX;
	if(p->player == WHITE) {
		// Maximising player
		bestScore = INT_MIN;
		for(int i=0; i<numMoves; i++) {
			m = &ml.list[i];
			makeMove(p, m, fs);
			// scores[i] = fastEvaluateMove(b, &ml.list[i], depth);
			switch(aiMode) {
				case DIRTY_AI:
					scores[i] = dirtyAlphaBeta(p, fs, depth, maxExtensions, alpha, beta);
				case NORMAL_AI:
				default:
					scores[i] = alphaBeta(p, fs, depth, maxExtensions, alpha, beta, m->cPiece);
			}
			unmakeMove(p, m, fs);
			if(verbose == TRUE) {
				// printf("\nFinal score for move: ");
				printf("(");
				outputMove(m, FALSE);
				printf(": %d) ", scores[i]);
			}
			if(scores[i] > bestScore) {
				bestScore = scores[i];
				bestIndex = i;
			}
			alpha = (alpha > bestScore) ? alpha : bestScore;
		}
	} else {
		// Minimising player
		bestScore = INT_MAX;
		for(int i=0; i<numMoves; i++) {
			m = &ml.list[i];
			makeMove(p, m, fs);
			// scores[i] = fastEvaluateMove(b, &ml.list[i], depth);
			switch(aiMode) {
				case DIRTY_AI:
					scores[i] = dirtyAlphaBeta(p, fs, depth, maxExtensions, alpha, beta);
				case NORMAL_AI:
				default:
					scores[i] = alphaBeta(p, fs, depth, maxExtensions, alpha, beta, m->cPiece);
			}
			unmakeMove(p, m, fs);
			if(verbose == TRUE) {
				printf("(");
				outputMove(m, FALSE);
				printf(": %d) ", scores[i]);
			}
			if(scores[i] < bestScore) {
				bestScore = scores[i];
				bestIndex = i;
			}
			beta = (beta < bestScore) ? beta : bestScore;
		}
	}
	returnMove = ml.list[bestIndex];
	if(verbose == TRUE) {
		printf("Best move: ");
		outputMove(&returnMove, FALSE);
		printf(" (%d)\n", bestScore);
	}
	freeMoveList(&ml);
	return returnMove;
}


Move* inputPlayerMove(MoveList *ml) {
	// char inp[6];
	Move m;
	int choice;
	while(TRUE) {
		printf("Choose a move:\n");
		outputMoveList(ml, ' ', FALSE);
		printf("\n> ");
		scanf("%d", &choice);
		choice--;
		if(choice == -1) {
			return NULL;
		}
		if(choice < 0 || choice >= ml->used) {
			continue;
		}
		return &ml->list[choice];
	}
}


void outputResult(int result) {
	printf("GAMEOVER!\nRESULT: ");
	switch(result) {
		case RES_WHITE_WIN:
			printf("White won by checkmate!\n"); break;
		case RES_BLACK_WIN:
			printf("Black won by checkmate!\n"); break;
		case RES_STALEMATE:
			printf("Draw by stalemate.\n"); break;
		case RES_THREEFOLD:
			printf("Draw by threefold repetition.\n"); break;
		case RES_FIFTY_MOVE:
			printf("Draw by fifty move rule.\n"); break;
		case RES_INSUFF_MATERIAL:
			printf("Draw by insufficient material.\n"); break;
	}
}


int onePlayerGame(int colour, int depth, int aiType, int maxExtensions, int verbose) {
	Position p;
	setupStartPosition(&p);
	IrrFlagStack fs;
	initIrrFlagStack(&fs, 40);

	Move playerMove;
	Move* inp;
	MoveList legalMoves;
	MoveList history;
	// MoveList captures;
	initMoveList(&history, 40);
	int result = 0;
	while(TRUE) {
		// pushBoardStack(&bs, b);
		outputPosition(&p);
		// outputAttackMaps(&p);
		// freeMoveList(&legalMoves);
		genLegalMoves(&legalMoves, &p, &fs);
		sortCapturesMVV(&legalMoves);
		// freeMoveList(&captures);
		// generateCaptures(&captures, &b);
		// printf("Captures: \n");
		// outputMoveList(&captures);
		if(legalMoves.used == 0) {
			result = finalResult(&p);
			break;
		}
		if(p.flag.plyCount >= 50) {
			result = RES_FIFTY_MOVE;
			break;
		}
		// TODO
		// if(detectThreefold(bs) || detectInsufficientMaterial(&b)) {
		// 	result = ...;
		// 	break;
		// }
		if(p.player == colour) {
			do {
				do {
					inp = inputPlayerMove(&legalMoves);
				} while(inp == NULL && (history.used == 0));
				if(inp == NULL) {
					unmakeMove(&p, popMoveList(&history), &fs);
					genLegalMoves(&legalMoves, &p, &fs);
					sortCapturesMVV(&legalMoves);
					outputPosition(&p);
				} else {
					playerMove = *inp;
				}
			} while(inp == NULL);

		} else {
			printf("Thinking...\n");

			playerMove = ai(&p, &fs, depth, aiType, maxExtensions, verbose);

			printf("Computer moves: ");
			outputMove(&playerMove, FALSE);
			printf("\n");
			// playerMove = inputPlayerMove(&legalMoves);
		}
		insertMoveList(&history, playerMove);
		makeMove(&p, &playerMove, &fs);
		// freeMoveList(&legalMoves);
	}
	// if(result == 0) {
	// 	result = scorePosition(&b);
	// }
	outputResult(result);
	freeMoveList(&legalMoves);
	freeMoveList(&history);
	// return result;
	return 0;
}

void testPosition() {
	Position p;
	IrrFlagStack fs;
	initIrrFlagStack(&fs, 10);

	setupStartPosition(&p);
	pushIrrFlagStack(&fs, &p);
	IrrFlag f = popIrrFlagStack(&fs);
	outputIrrFlag(f);

	outputPosition(&p);

	Move e4 = createMove(E2_INT, E4_INT, FLAG_DOUBLE_PAWN_PUSH, W_PAWN, WHITE, 0, 0);
	makeMove(&p, &e4, &fs);
	outputPosition(&p);
	Move e5 = createMove(E7_INT, E5_INT, FLAG_DOUBLE_PAWN_PUSH, B_PAWN, BLACK, 0, 0);
	makeMove(&p, &e5, &fs);
	outputPosition(&p);
	Move nf3 = createMove(G1_INT, F3_INT, FLAG_QUIET_MOVE, W_KNIGHT, WHITE, 0, 0);
	makeMove(&p, &nf3, &fs);
	outputPosition(&p);
	Move nf6 = createMove(G8_INT, F6_INT, FLAG_QUIET_MOVE, B_KNIGHT, BLACK, 0, 0);
	makeMove(&p, &nf6, &fs);
	outputPosition(&p);
	Move bc4 = createMove(F1_INT, C4_INT, FLAG_QUIET_MOVE, W_BISHOP, WHITE, 0, 0);
	makeMove(&p, &bc4, &fs);
	outputPosition(&p);
	Move bc5 = createMove(F8_INT, C5_INT, FLAG_QUIET_MOVE, B_BISHOP, BLACK, 0, 0);
	makeMove(&p, &bc5, &fs);
	outputPosition(&p);
	Move wc = createMove(E1_INT, G1_INT, FLAG_KING_CASTLE, W_KING, WHITE, 0, 0);
	makeMove(&p, &wc, &fs);
	outputPosition(&p);

	printf("Eval: %d\n", heuristicEval(&p));

	Move bc = createMove(E8_INT, G8_INT, FLAG_KING_CASTLE, B_KING, BLACK, 0, 0);
	makeMove(&p, &bc, &fs);
	outputPosition(&p);

	printf("Eval: %d\n", heuristicEval(&p));

	freeIrrFlagStack(&fs);

}

void testMove() {
	Move m;
	m.from = 61;
	m.to = 33;
	m.flags = 15;
	printf("%d %d %d\n", m.from, m.to, m.flags);
}

void testMoveGen() {
	Position p;
	IrrFlagStack fs;
	MoveList ml;
	initIrrFlagStack(&fs, 10);
	setupStartPosition(&p);
	pushIrrFlagStack(&fs, &p);

	outputPosition(&p);
	genMoves(&ml, &p);
	outputMoveList(&ml, '\n', FALSE);

	Move e4 = createMove(E2_INT, E4_INT, FLAG_DOUBLE_PAWN_PUSH, W_PAWN, WHITE, 0, 0);
	makeMove(&p, &e4, &fs);
	outputPosition(&p);
	genMoves(&ml, &p);
	outputMoveList(&ml, '\n', FALSE);
	Move e5 = createMove(E7_INT, E5_INT, FLAG_DOUBLE_PAWN_PUSH, B_PAWN, BLACK, 0, 0);
	makeMove(&p, &e5, &fs);
	outputPosition(&p);
	genMoves(&ml, &p);
	outputMoveList(&ml, '\n', FALSE);
	Move nf3 = createMove(G1_INT, F3_INT, FLAG_QUIET_MOVE, W_KNIGHT, WHITE, 0, 0);
	makeMove(&p, &nf3, &fs);
	outputPosition(&p);
	genMoves(&ml, &p);
	outputMoveList(&ml, '\n', FALSE);
	Move nf6 = createMove(G8_INT, F6_INT, FLAG_QUIET_MOVE, B_KNIGHT, BLACK, 0, 0);
	makeMove(&p, &nf6, &fs);
	outputPosition(&p);
	genMoves(&ml, &p);
	outputMoveList(&ml, '\n', FALSE);

	freeMoveList(&ml);
}

long perft(Position* b, IrrFlagStack* fs, int depth) {
	if(depth == 0) {
		return 1;
	} else {
		MoveList ml;
		Move m;
		genLegalMoves(&ml, b, fs);
		if(ml.used == 0) {
			return 0;
		}
		int i;
		long total = 0;
		for(i=0; i<ml.used; i++) {
			m = ml.list[i];
			makeMove(b, &m, fs);
			total += perft(b, fs, depth - 1);
			unmakeMove(b, &m, fs);
			if(depth == 6) {
				outputMove(&m, FALSE);
			}
		}
		freeMoveList(&ml);
		if(depth == 5) {
			printf("\t%ld\n", total);
		}
		return total;
	}
}

void testPerft(int depth) {
	Position p;
	setupStartPosition(&p);
	IrrFlagStack fs;
	initIrrFlagStack(&fs, 10);

	printf("%ld\n", perft(&p, &fs, depth));

	freeIrrFlagStack(&fs);
}

void testAI(int depth) {
	printf("test\n");
	Position p;
	setupStartPosition(&p);
	IrrFlagStack fs;
	initIrrFlagStack(&fs, 10);

	printf("%d\n", heuristicEval(&p));

	freeIrrFlagStack(&fs);
}

int main(int argc, char** argv) {
	initGlobalArrays();
	if(argc > 2) {
		char* input1 = argv[1];
		char* input2 = argv[2];
		int mode, depth, extensions;
		sscanf(argv[1], "%d", &mode);
		sscanf(argv[2], "%d", &depth);
		sscanf(argv[3], "%d", &extensions);
		if(mode < 0 || mode > 10 || depth < 0) {
			return -1;
		}
		switch(mode) {
			case 0:
				testPerft(depth); break;
			case 1:
				printf("Selected dirtyAI, WHITE\n");
				onePlayerGame(WHITE, depth, DIRTY_AI, extensions, TRUE); break;
			case 2:
				printf("Selected dirtyAI, BLACK\n");
				onePlayerGame(BLACK, depth, DIRTY_AI, extensions, TRUE); break;
			case 3:
				printf("Selected normalAI, WHITE\n");
				onePlayerGame(WHITE, depth, NORMAL_AI, extensions, TRUE); break;
			case 4:
				printf("Selected normalAI, BLACK\n");
				onePlayerGame(BLACK, depth, NORMAL_AI, extensions, TRUE); break;
			case 5:
				testAI(depth);
			case 6:
				testPosition();


		}
	}
	// testPosition();
	// testMove();
	// testMoveGen();
	// testPerft(5);
	// onePlayerGame(WHITE, 0, 0, 0);
	freeGlobalArrays();
	return 0;
}
